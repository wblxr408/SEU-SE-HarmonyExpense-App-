/**
 * æ€§èƒ½ç›‘æ§è£…é¥°å™¨ - ä¼ä¸šçº§æ•°æ®åº“æ€§èƒ½ç›‘æ§æ–¹æ¡ˆï¼ˆâ­ äº®ç‚¹ï¼‰
 * 
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * 1. è‡ªåŠ¨è®°å½•æŸ¥è¯¢æ‰§è¡Œæ—¶é—´
 * 2. æ…¢æŸ¥è¯¢è­¦å‘Šï¼ˆ> 100msï¼‰
 * 3. é”™è¯¯æ•è·å’Œæ—¥å¿—è®°å½•
 * 4. é›¶ä¾µå…¥å¼ç›‘æ§ï¼ˆä½¿ç”¨è£…é¥°å™¨æ¨¡å¼ï¼‰
 * 
 * æŠ€æœ¯äº®ç‚¹ï¼š
 * - è£…é¥°å™¨æ¨¡å¼ï¼ˆDecorator Patternï¼‰ï¼šåœ¨ä¸ä¿®æ”¹åŸæœ‰ä»£ç çš„æƒ…å†µä¸‹å¢å¼ºåŠŸèƒ½
 * - AOP æ€æƒ³ï¼ˆé¢å‘åˆ‡é¢ç¼–ç¨‹ï¼‰ï¼šå°†æ€§èƒ½ç›‘æ§ä½œä¸ºæ¨ªåˆ‡å…³æ³¨ç‚¹ç»Ÿä¸€å¤„ç†
 * - ä¼ä¸šçº§å®è·µï¼šç”Ÿäº§ç¯å¢ƒå¸¸ç”¨çš„æ€§èƒ½ç›‘æ§æ–¹æ¡ˆ
 * 
 * ä½¿ç”¨ç¤ºä¾‹ï¼š
 * ```typescript
 * class BillDAO {
 *   @measureQueryTime
 *   static async getAll(): Promise<Bill[]> {
 *     // æŸ¥è¯¢é€»è¾‘
 *   }
 * }
 * ```
 */

/**
 * æ€§èƒ½ç›‘æ§è£…é¥°å™¨
 * 
 * åŠŸèƒ½ï¼š
 * - è‡ªåŠ¨è®°å½•æ–¹æ³•æ‰§è¡Œæ—¶é—´
 * - æ…¢æŸ¥è¯¢è­¦å‘Šï¼ˆ> 100msï¼‰
 * - é”™è¯¯æ•è·å’Œæ—¥å¿—è®°å½•
 * 
 * æŠ€æœ¯åŸç†ï¼š
 * 1. è£…é¥°å™¨æ¨¡å¼ï¼šåŒ…è£…åŸå§‹æ–¹æ³•ï¼Œåœ¨æ‰§è¡Œå‰åæ·»åŠ ç›‘æ§é€»è¾‘
 * 2. AOP æ€æƒ³ï¼šå°†æ€§èƒ½ç›‘æ§ä½œä¸ºæ¨ªåˆ‡å…³æ³¨ç‚¹ï¼Œä¸ä¸šåŠ¡é€»è¾‘è§£è€¦
 * 3. é›¶ä¾µå…¥ï¼šä¸ä¿®æ”¹åŸæœ‰ä»£ç ï¼Œé€šè¿‡è£…é¥°å™¨è¯­æ³•ç³–å®ç°
 * 
 * @param target ç›®æ ‡ç±»
 * @param propertyKey æ–¹æ³•å
 * @param descriptor æ–¹æ³•æè¿°ç¬¦
 */
export function measureQueryTime(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
): PropertyDescriptor {
  const originalMethod = descriptor.value;

  descriptor.value = async function (...args: any[]) {
    const className = target.constructor.name;
    const methodName = propertyKey;
    const startTime = Date.now();

    console.log(`[PerformanceMonitor] ğŸš€ å¼€å§‹æ‰§è¡Œ: ${className}.${methodName}()`);

    try {
      // æ‰§è¡ŒåŸå§‹æ–¹æ³•
      const result = await originalMethod.apply(this, args);
      
      // è®¡ç®—æ‰§è¡Œæ—¶é—´
      const endTime = Date.now();
      const duration = endTime - startTime;

      // æ…¢æŸ¥è¯¢è­¦å‘Šï¼ˆ> 100msï¼‰
      if (duration > 100) {
        console.warn(
          `[PerformanceMonitor] âš ï¸ æ…¢æŸ¥è¯¢è­¦å‘Š: ${className}.${methodName}() ` +
          `è€—æ—¶ ${duration}ms (è¶…è¿‡ 100ms é˜ˆå€¼)`
        );
      } else {
        console.log(
          `[PerformanceMonitor] âœ… æ‰§è¡Œå®Œæˆ: ${className}.${methodName}() ` +
          `è€—æ—¶ ${duration}ms`
        );
      }

      return result;
    } catch (error) {
      // é”™è¯¯æ•è·å’Œæ—¥å¿—è®°å½•
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      console.error(
        `[PerformanceMonitor] âŒ æ‰§è¡Œå¤±è´¥: ${className}.${methodName}() ` +
        `è€—æ—¶ ${duration}ms, é”™è¯¯:`, error
      );
      
      throw error;
    }
  };

  return descriptor;
}

/**
 * æ€§èƒ½ç›‘æ§ç®¡ç†å™¨
 * 
 * æä¾›æ›´çµæ´»çš„æ€§èƒ½ç›‘æ§åŠŸèƒ½ï¼š
 * - æ‰‹åŠ¨å¼€å§‹/ç»“æŸè®¡æ—¶
 * - æ€§èƒ½ç»Ÿè®¡æ±‡æ€»
 * - æ…¢æŸ¥è¯¢æ—¥å¿—å¯¼å‡º
 */
export class PerformanceMonitor {
  // æ…¢æŸ¥è¯¢é˜ˆå€¼ï¼ˆæ¯«ç§’ï¼‰
  private static readonly SLOW_QUERY_THRESHOLD = 100;
  
  // æ€§èƒ½ç»Ÿè®¡æ•°æ®
  private static stats: Map<string, {
    count: number;
    totalTime: number;
    avgTime: number;
    maxTime: number;
    minTime: number;
    slowQueryCount: number;
  }> = new Map();

  /**
   * è®°å½•æŸ¥è¯¢æ€§èƒ½
   * 
   * @param methodName æ–¹æ³•å
   * @param duration æ‰§è¡Œæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   */
  static recordQuery(methodName: string, duration: number): void {
    const stats = PerformanceMonitor.stats.get(methodName) || {
      count: 0,
      totalTime: 0,
      avgTime: 0,
      maxTime: 0,
      minTime: Infinity,
      slowQueryCount: 0
    };

    stats.count++;
    stats.totalTime += duration;
    stats.avgTime = stats.totalTime / stats.count;
    stats.maxTime = Math.max(stats.maxTime, duration);
    stats.minTime = Math.min(stats.minTime, duration);
    
    if (duration > PerformanceMonitor.SLOW_QUERY_THRESHOLD) {
      stats.slowQueryCount++;
    }

    PerformanceMonitor.stats.set(methodName, stats);
  }

  /**
   * è·å–æ€§èƒ½ç»Ÿè®¡æŠ¥å‘Š
   * 
   * @returns æ€§èƒ½ç»Ÿè®¡æ•°æ®
   */
  static getStats(): Map<string, any> {
    return new Map(PerformanceMonitor.stats);
  }

  /**
   * æ‰“å°æ€§èƒ½ç»Ÿè®¡æŠ¥å‘Š
   */
  static printStats(): void {
    console.log('\n========== æ€§èƒ½ç»Ÿè®¡æŠ¥å‘Š ==========');
    
    if (PerformanceMonitor.stats.size === 0) {
      console.log('æš‚æ— æ€§èƒ½æ•°æ®');
      return;
    }

    PerformanceMonitor.stats.forEach((stats, methodName) => {
      console.log(`\næ–¹æ³•: ${methodName}`);
      console.log(`  è°ƒç”¨æ¬¡æ•°: ${stats.count}`);
      console.log(`  æ€»è€—æ—¶: ${stats.totalTime.toFixed(2)}ms`);
      console.log(`  å¹³å‡è€—æ—¶: ${stats.avgTime.toFixed(2)}ms`);
      console.log(`  æœ€å¤§è€—æ—¶: ${stats.maxTime.toFixed(2)}ms`);
      console.log(`  æœ€å°è€—æ—¶: ${stats.minTime === Infinity ? 0 : stats.minTime.toFixed(2)}ms`);
      console.log(`  æ…¢æŸ¥è¯¢æ¬¡æ•°: ${stats.slowQueryCount}`);
      
      if (stats.slowQueryCount > 0) {
        const slowQueryRate = (stats.slowQueryCount / stats.count * 100).toFixed(2);
        console.log(`  æ…¢æŸ¥è¯¢æ¯”ä¾‹: ${slowQueryRate}%`);
      }
    });
    
    console.log('\n==================================\n');
  }

  /**
   * æ¸…é™¤æ€§èƒ½ç»Ÿè®¡æ•°æ®
   */
  static clearStats(): void {
    PerformanceMonitor.stats.clear();
    console.log('[PerformanceMonitor] æ€§èƒ½ç»Ÿè®¡æ•°æ®å·²æ¸…é™¤');
  }

  /**
   * æ‰‹åŠ¨æµ‹é‡æ–¹æ³•æ‰§è¡Œæ—¶é—´
   * 
   * ä½¿ç”¨ç¤ºä¾‹ï¼š
   * ```typescript
   * const result = await PerformanceMonitor.measure('myMethod', async () => {
   *   // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
   *   return await someAsyncOperation();
   * });
   * ```
   */
  static async measure<T>(
    methodName: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const startTime = Date.now();
    console.log(`[PerformanceMonitor] ğŸš€ å¼€å§‹æ‰§è¡Œ: ${methodName}`);

    try {
      const result = await fn();
      
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      // è®°å½•æ€§èƒ½æ•°æ®
      PerformanceMonitor.recordQuery(methodName, duration);

      // æ…¢æŸ¥è¯¢è­¦å‘Š
      if (duration > PerformanceMonitor.SLOW_QUERY_THRESHOLD) {
        console.warn(
          `[PerformanceMonitor] âš ï¸ æ…¢æŸ¥è¯¢è­¦å‘Š: ${methodName} ` +
          `è€—æ—¶ ${duration}ms (è¶…è¿‡ ${PerformanceMonitor.SLOW_QUERY_THRESHOLD}ms é˜ˆå€¼)`
        );
      } else {
        console.log(
          `[PerformanceMonitor] âœ… æ‰§è¡Œå®Œæˆ: ${methodName} è€—æ—¶ ${duration}ms`
        );
      }

      return result;
    } catch (error) {
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      console.error(
        `[PerformanceMonitor] âŒ æ‰§è¡Œå¤±è´¥: ${methodName} è€—æ—¶ ${duration}ms, é”™è¯¯:`, error
      );
      
      throw error;
    }
  }
}
