/**
 * é€šçŸ¥ä¸­å¿ƒé¡µé¢
 * æ˜¾ç¤ºç³»ç»Ÿé€šçŸ¥åˆ—è¡¨ï¼Œæ”¯æŒç­›é€‰å’Œå…¨éƒ¨å·²è¯»
 */
import router from '@ohos.router';
import promptAction from '@ohos.promptAction';
import { NotificationService } from '../service/NotificationService';
import { Notification, NotificationType } from '../model/Notification';

@Entry
@Component
struct NotificationCenterPage {
  @State notifications: Notification[] = [];
  @State selectedTab: number = 0;
  @State isLoading: boolean = true;
  @State unreadCount: number = 0;

  private tabs: string[] = ['å…¨éƒ¨', 'ç³»ç»Ÿ', 'é¢„ç®—', 'åŒæ­¥', 'æé†’'];
  private tabTypes: (NotificationType | null)[] = [
    null,
    NotificationType.SYSTEM,
    NotificationType.BUDGET_ALERT,
    NotificationType.SYNC_STATUS,
    NotificationType.REMINDER
  ];

  async aboutToAppear() {
    await this.loadNotifications();
  }

  async loadNotifications() {
    this.isLoading = true;
    try {
      const type = this.tabTypes[this.selectedTab];
      if (type === null) {
        this.notifications = await NotificationService.getNotifications(100);
      } else {
        this.notifications = await NotificationService.getByType(type);
      }
      this.unreadCount = await NotificationService.getUnreadCount();
    } catch (error) {
      console.error('[NotificationCenterPage] åŠ è½½é€šçŸ¥å¤±è´¥:', error);
    } finally {
      this.isLoading = false;
    }
  }

  build() {
    Navigation() {
      Column() {
        // Tab ç­›é€‰
        Row() {
          ForEach(this.tabs, (tab: string, index: number) => {
            Text(tab)
              .fontSize(14)
              .fontColor(this.selectedTab === index ? '#2E65F3' : '#8395A7')
              .fontWeight(this.selectedTab === index ? FontWeight.Bold : FontWeight.Normal)
              .padding({ left: 12, right: 12, top: 8, bottom: 8 })
              .backgroundColor(this.selectedTab === index ? 'rgba(46, 101, 243, 0.1)' : Color.Transparent)
              .borderRadius(16)
              .onClick(() => {
                this.selectedTab = index;
                this.loadNotifications();
              })
          })
        }
        .width('100%')
        .padding(12)
        .justifyContent(FlexAlign.SpaceAround)

        // å…¨éƒ¨å·²è¯»æŒ‰é’®
        if (this.unreadCount > 0) {
          Row() {
            Text(`${this.unreadCount} æ¡æœªè¯»`)
              .fontSize(14)
              .fontColor('#8395A7')
              .layoutWeight(1)
            Text('å…¨éƒ¨å·²è¯»')
              .fontSize(14)
              .fontColor('#2E65F3')
              .onClick(() => this.markAllAsRead())
          }
          .width('100%')
          .padding({ left: 16, right: 16, top: 8, bottom: 8 })
          .backgroundColor(Color.White)
        }

        // é€šçŸ¥åˆ—è¡¨
        if (this.isLoading) {
          LoadingProgress()
            .width(50)
            .height(50)
            .margin({ top: 100 })
        } else if (this.notifications.length === 0) {
          // ç©ºçŠ¶æ€
          Column() {
            Text('ğŸ””')
              .fontSize(60)
              .margin({ bottom: 16 })
            Text('æš‚æ— é€šçŸ¥')
              .fontSize(16)
              .fontColor('#8395A7')
          }
          .width('100%')
          .margin({ top: 100 })
        } else {
          List() {
            ForEach(this.notifications, (notification: Notification) => {
              ListItem() {
                this.NotificationItem(notification)
              }
            })
          }
          .width('100%')
          .layoutWeight(1)
          .divider({ strokeWidth: 1, color: '#F0F0F0', startMargin: 16 })
          .backgroundColor(Color.White)
        }
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#F5F7F9')
    }
    .title('é€šçŸ¥ä¸­å¿ƒ')
    .titleMode(NavigationTitleMode.Mini)
  }

  @Builder
  NotificationItem(notification: Notification) {
    Row() {
      // ç±»å‹å›¾æ ‡
      Text(this.getTypeIcon(notification.type))
        .fontSize(24)
        .width(40)
        .height(40)
        .textAlign(TextAlign.Center)
        .backgroundColor(notification.isRead === 0 ? 'rgba(46, 101, 243, 0.1)' : '#F5F7F9')
        .borderRadius(20)
        .margin({ right: 12 })

      Column() {
        Row() {
          Text(notification.title)
            .fontSize(16)
            .fontColor('#2D3436')
            .fontWeight(notification.isRead === 0 ? FontWeight.Bold : FontWeight.Normal)
            .layoutWeight(1)
          if (notification.isRead === 0) {
            Circle()
              .width(8)
              .height(8)
              .fill('#FF4D4F')
          }
        }
        .width('100%')

        Text(notification.content)
          .fontSize(14)
          .fontColor('#8395A7')
          .maxLines(2)
          .textOverflow({ overflow: TextOverflow.Ellipsis })
          .margin({ top: 4 })

        Text(this.formatTime(notification.createdAt))
          .fontSize(12)
          .fontColor('#BDBDBD')
          .margin({ top: 4 })
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)
    }
    .width('100%')
    .padding(16)
    .backgroundColor(Color.White)
    .onClick(() => this.markAsRead(notification))
  }

  getTypeIcon(type: NotificationType): string {
    switch (type) {
      case NotificationType.SYSTEM: return 'ğŸ“¢';
      case NotificationType.BUDGET_ALERT: return 'ğŸ’°';
      case NotificationType.SYNC_STATUS: return 'ğŸ”„';
      case NotificationType.REMINDER: return 'â°';
      default: return 'ğŸ””';
    }
  }

  formatTime(dateStr: string): string {
    if (!dateStr) return '';
    const date = new Date(dateStr);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return 'åˆšåˆš';
    if (minutes < 60) return `${minutes}åˆ†é’Ÿå‰`;
    if (hours < 24) return `${hours}å°æ—¶å‰`;
    if (days < 7) return `${days}å¤©å‰`;
    return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
  }

  async markAsRead(notification: Notification) {
    if (notification.isRead === 0) {
      await NotificationService.markAsRead(notification.notificationId);
      notification.isRead = 1;
      this.unreadCount = Math.max(0, this.unreadCount - 1);
    }
  }

  async markAllAsRead() {
    await NotificationService.markAllAsRead();
    this.notifications.forEach(n => n.isRead = 1);
    this.unreadCount = 0;
    promptAction.showToast({ message: 'å·²å…¨éƒ¨æ ‡è®°ä¸ºå·²è¯»' });
  }
}
