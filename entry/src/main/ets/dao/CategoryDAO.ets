import relationalStore from '@ohos.data.relationalStore';
import common from '@ohos.app.ability.common';
import { Category } from '../model/Category';

let db: relationalStore.RdbStore | null = null;

/**
 * åˆ†ç±»æ•°æ®è®¿é—®å¯¹è±¡ - CategoryDAO
 * å¯¹åº”è¡¨ï¼šcategories
 * åŠŸèƒ½ï¼šæä¾›åˆ†ç±»ï¼ˆæ”¶å…¥/æ”¯å‡ºï¼‰æ•°æ®çš„å¢åˆ æ”¹æŸ¥æ“ä½œ
 */
export class CategoryDAO {
  /** åˆå§‹åŒ–æ•°æ®åº“è¿æ¥ */
  static async initDatabase(context: common.Context) {
    const storeConfig: relationalStore.StoreConfig = {
      name: 'harmony_expense.db',
      securityLevel: relationalStore.SecurityLevel.S1
    };
    try {
      db = await relationalStore.getRdbStore(context, storeConfig);
      console.log('[CategoryDAO] æ•°æ®åº“å·²åˆå§‹åŒ–');
      await CategoryDAO.createTables();
    } catch (error) {
      console.error('[CategoryDAO] åˆå§‹åŒ–æ•°æ®åº“å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] åˆå§‹åŒ–æ•°æ®åº“å¤±è´¥', error);
    }
  }

  /** åˆ›å»ºåˆ†ç±»è¡¨å’Œç´¢å¼•ï¼ˆè‹¥ä¸å­˜åœ¨ï¼‰ */
  static async createTables() {
    const store = CategoryDAO.ensureDb();
    try {
      await store.executeSql(`
        CREATE TABLE IF NOT EXISTS categories (
          category_id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id INTEGER NOT NULL,
          name TEXT NOT NULL,
          type TEXT NOT NULL CHECK (type IN ('expense', 'income')),
          icon TEXT DEFAULT 'ğŸ“¦',
          color TEXT DEFAULT '#1890FF',
          parent_category_id INTEGER DEFAULT 0,
          created_at TEXT NOT NULL,
          updated_at TEXT NOT NULL,
          is_deleted INTEGER DEFAULT 0 CHECK (is_deleted IN (0, 1)),
          UNIQUE (user_id, name, type)
        );
      `);
      // ç´¢å¼•
      await store.executeSql(`CREATE INDEX IF NOT EXISTS idx_categories_user_type ON categories (user_id, type);`);
      await store.executeSql(`CREATE INDEX IF NOT EXISTS idx_categories_user_parent ON categories (user_id, parent_category_id);`);
      console.log('[CategoryDAO] åˆ†ç±»è¡¨å’Œç´¢å¼•åˆ›å»ºå®Œæˆ');
    } catch (error) {
      console.error('[CategoryDAO] åˆ›å»ºè¡¨æˆ–ç´¢å¼•å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] åˆ›å»ºè¡¨æˆ–ç´¢å¼•å¤±è´¥', error);
    }
  }

  /** æ’å…¥æ–°åˆ†ç±» */
  static async insert(category: Category) {
    if (!category.validate()) {
      throw new Error('[CategoryDAO] æ— æ•ˆåˆ†ç±»æ•°æ®');
    }
    const store = CategoryDAO.ensureDb();
    const now = new Date().toISOString();
    const sql = `
      INSERT INTO categories
        (user_id, name, type, icon, color, parent_category_id, created_at, updated_at, is_deleted)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
    const params = [
      category.userId,
      category.name,
      category.type,
      category.icon,
      category.color,
      category.parentCategoryId,
      now,
      now,
      0
    ];
    try {
      await store.executeSql(sql, params);
      console.log(`[CategoryDAO] æ’å…¥æˆåŠŸ: ${category.name}`);
    } catch (error) {
      console.error('[CategoryDAO] æ’å…¥å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æ’å…¥å¤±è´¥', error);
    }
  }

  /** æ‰¹é‡æ’å…¥åˆ†ç±» */
  static async bulkInsert(categories: Category[]) {
    const store = CategoryDAO.ensureDb();
    await store.beginTransaction();
    try {
      for (const category of categories) {
        await CategoryDAO.insert(category);
      }
      await store.commit();
      console.log(`[CategoryDAO] æ‰¹é‡æ’å…¥æˆåŠŸ: ${categories.length} æ¡`);
    } catch (error) {
      await store.rollBack();
      console.error('[CategoryDAO] æ‰¹é‡æ’å…¥å¤±è´¥: ' + JSON.stringify(error));
      throw error instanceof Error ? error : new Error(String(error));
    }
  }



  /** æ ¹æ® ID æŸ¥è¯¢åˆ†ç±»ï¼ˆåªè¿”å›æœªåˆ é™¤ï¼‰ */
  static async getById(userId: number, categoryId: number): Promise<Category | null> {
    const store = CategoryDAO.ensureDb();
    const sql = `SELECT * FROM categories WHERE category_id = ? AND user_id = ? AND is_deleted = 0`;
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [categoryId, userId]);
      if (!resultSet.goToNextRow()) return null;
      return CategoryDAO.mapRowToCategory(resultSet);
    } catch (error) {
      console.error('[CategoryDAO] æŸ¥è¯¢å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æŸ¥è¯¢å¤±è´¥', error);
    } finally {
      resultSet?.close();
    }
  }

  /** æŸ¥è¯¢ç”¨æˆ·æ‰€æœ‰æœªåˆ é™¤åˆ†ç±» */
  static async getAll(userId: number): Promise<Category[]> {
    const store = CategoryDAO.ensureDb();
    const sql = `SELECT * FROM categories WHERE user_id = ? AND is_deleted = 0 ORDER BY category_id ASC`;
    const categories: Category[] = [];
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [userId]);
      while (resultSet.goToNextRow()) {
        categories.push(CategoryDAO.mapRowToCategory(resultSet));
      }
      return categories;
    } catch (error) {
      console.error('[CategoryDAO] æŸ¥è¯¢å…¨éƒ¨å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æŸ¥è¯¢å…¨éƒ¨å¤±è´¥', error);
    } finally {
      resultSet?.close();
    }
  }

  /** æŒ‰ç±»å‹æŸ¥è¯¢ï¼ˆæ”¶å…¥/æ”¯å‡ºï¼‰ */
  static async getByType(userId: number, type: 'expense' | 'income'): Promise<Category[]> {
    const store = CategoryDAO.ensureDb();
    const sql = `SELECT * FROM categories WHERE user_id = ? AND type = ? AND is_deleted = 0 ORDER BY category_id ASC`;
    const categories: Category[] = [];
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [userId, type]);
      while (resultSet.goToNextRow()) {
        categories.push(CategoryDAO.mapRowToCategory(resultSet));
      }
      return categories;
    } finally {
      resultSet?.close();
    }
  }

  /** è·å–æŸä¸ªçˆ¶åˆ†ç±»çš„å­åˆ†ç±» */
  static async getChildren(userId: number, parentId: number): Promise<Category[]> {
    const store = CategoryDAO.ensureDb();
    const sql = `SELECT * FROM categories WHERE user_id = ? AND parent_category_id = ? AND is_deleted = 0 ORDER BY category_id ASC`;
    const categories: Category[] = [];
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [userId, parentId]);
      while (resultSet.goToNextRow()) {
        categories.push(CategoryDAO.mapRowToCategory(resultSet));
      }
      return categories;
    } finally {
      resultSet?.close();
    }
  }

  /** æ›´æ–°åˆ†ç±»ä¿¡æ¯ */
  static async update(category: Category) {
    if (!category.validate()) {
      throw new Error('[CategoryDAO] æ— æ•ˆåˆ†ç±»æ•°æ®');
    }
    const store = CategoryDAO.ensureDb();
    const now = new Date().toISOString();
    const sql = `
      UPDATE categories
      SET name = ?, type = ?, icon = ?, color = ?, parent_category_id = ?, updated_at = ?, is_deleted = ?
      WHERE category_id = ? AND user_id = ?
    `;
    const params = [
      category.name,
      category.type,
      category.icon,
      category.color,
      category.parentCategoryId,
      now,
      category.is_deleted,
      category.categoryId,
      category.userId
    ];
    try {
      await store.executeSql(sql, params);
      console.log(`[CategoryDAO] æ›´æ–°æˆåŠŸ: ${category.name}`);
    } catch (error) {
      console.error('[CategoryDAO] æ›´æ–°å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æ›´æ–°å¤±è´¥', error);
    }
  }

  /** è½¯åˆ é™¤åˆ†ç±» */
  static async softDelete(userId: number, categoryId: number) {
    const store = CategoryDAO.ensureDb();
    const now = new Date().toISOString();
    const sql = `UPDATE categories SET is_deleted = 1, updated_at = ? WHERE category_id = ? AND user_id = ?`;
    try {
      await store.executeSql(sql, [now, categoryId, userId]);
      console.log(`[CategoryDAO] è½¯åˆ é™¤æˆåŠŸ: category_id=${categoryId}`);
    } catch (error) {
      console.error('[CategoryDAO] è½¯åˆ é™¤å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] è½¯åˆ é™¤å¤±è´¥', error);
    }
  }

  /** æ¢å¤å·²åˆ é™¤åˆ†ç±» */
  static async restore(userId: number, categoryId: number) {
    const store = CategoryDAO.ensureDb();
    const now = new Date().toISOString();
    const sql = `UPDATE categories SET is_deleted = 0, updated_at = ? WHERE category_id = ? AND user_id = ?`;
    try {
      await store.executeSql(sql, [now, categoryId, userId]);
      console.log(`[CategoryDAO] æ¢å¤æˆåŠŸ: category_id=${categoryId}`);
    } catch (error) {
      console.error('[CategoryDAO] æ¢å¤å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æ¢å¤å¤±è´¥', error);
    }
  }

  /** çœŸåˆ é™¤åˆ†ç±»ï¼ˆæ…ç”¨ï¼‰ */
  static async hardDelete(userId: number, categoryId: number) {
    const store = CategoryDAO.ensureDb();
    const sql = `DELETE FROM categories WHERE category_id = ? AND user_id = ?`;
    try {
      await store.executeSql(sql, [categoryId, userId]);
      console.log(`[CategoryDAO] ç¡¬åˆ é™¤æˆåŠŸ: category_id=${categoryId}`);
    } catch (error) {
      console.error('[CategoryDAO] åˆ é™¤å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] åˆ é™¤å¤±è´¥', error);
    }
  }


  /** ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ– */
  private static ensureDb(): relationalStore.RdbStore {
    if (!db) {
      throw new Error('[CategoryDAO] Database has not been initialized. Call initDatabase first.');
    }
    return db;
  }

  /** ç»Ÿä¸€é”™è¯¯è½¬æ¢ */
  private static toError(message: string, err: Error | string | Record<string, Object>): Error {
    let details = '';
    try {
      details = typeof err === 'string' ? err : JSON.stringify(err);
    } catch (_) {
      details = '';
    }
    return new Error(`${message}${details ? ' -> ' + details : ''}`);
  }

  /** å°†æŸ¥è¯¢ç»“æœæ˜ å°„ä¸º Category å®ä¾‹ */
  private static mapRowToCategory(resultSet: relationalStore.ResultSet): Category {
    const category = new Category();
    category.categoryId = resultSet.getLong(resultSet.getColumnIndex('category_id'));
    category.userId = resultSet.getLong(resultSet.getColumnIndex('user_id'));
    category.name = resultSet.getString(resultSet.getColumnIndex('name'));
    category.type = resultSet.getString(resultSet.getColumnIndex('type')) as 'expense' | 'income';
    category.icon = resultSet.getString(resultSet.getColumnIndex('icon'));
    category.color = resultSet.getString(resultSet.getColumnIndex('color'));
    category.parentCategoryId = resultSet.getLong(resultSet.getColumnIndex('parent_category_id'));
    category.createdAt = resultSet.getString(resultSet.getColumnIndex('created_at'));
    category.updatedAt = resultSet.getString(resultSet.getColumnIndex('updated_at'));
    category.is_deleted = resultSet.getLong(resultSet.getColumnIndex('is_deleted'));
    return category;
  }

  static async exists(categoryId: number): Promise<boolean> {
    const sql = `SELECT 1 FROM categories WHERE category_id = ? AND is_deleted = 0`;
    const store = CategoryDAO.ensureDb();
    let rs: relationalStore.ResultSet | null = null;
    try {
      rs = await store.querySql(sql, [categoryId]);
      return rs.goToNextRow();
    } finally {
      if (rs) rs.close();
    }
  }

}
