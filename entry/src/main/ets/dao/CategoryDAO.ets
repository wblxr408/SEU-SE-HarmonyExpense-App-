import relationalStore from '@ohos.data.relationalStore';
import common from '@ohos.app.ability.common';
import { Category } from '../model/Category';
import { CategoryTreeNode, CategoryAggregation } from '../model/AggregationTypes';

let db: relationalStore.RdbStore | null = null;

/**
 * åˆ†ç±»æ•°æ®è®¿é—®å¯¹è±¡ - CategoryDAO
 * å¯¹åº”è¡¨ï¼šcategories
 * åŠŸèƒ½ï¼šæä¾›åˆ†ç±»ï¼ˆæ”¶å…¥/æ”¯å‡ºï¼‰æ•°æ®çš„å¢åˆ æ”¹æŸ¥æ“ä½œ
 */
export class CategoryDAO {
  /** åˆå§‹åŒ–æ•°æ®åº“è¿æ¥ */
  static async initDatabase(context: common.Context) {
    const storeConfig: relationalStore.StoreConfig = {
      name: 'harmony_expense.db',
      securityLevel: relationalStore.SecurityLevel.S1
    };
    try {
      db = await relationalStore.getRdbStore(context, storeConfig);
      console.log('[CategoryDAO] æ•°æ®åº“å·²åˆå§‹åŒ–');
      await CategoryDAO.createTables();
    } catch (error) {
      console.error('[CategoryDAO] åˆå§‹åŒ–æ•°æ®åº“å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] åˆå§‹åŒ–æ•°æ®åº“å¤±è´¥', error);
    }
  }

  /** åˆ›å»ºåˆ†ç±»è¡¨å’Œç´¢å¼•ï¼ˆè‹¥ä¸å­˜åœ¨ï¼‰ */
  static async createTables() {
    const store = CategoryDAO.ensureDb();
    try {
      await store.executeSql(`
        CREATE TABLE IF NOT EXISTS categories (
          category_id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id INTEGER NOT NULL,
          name TEXT NOT NULL,
          type TEXT NOT NULL CHECK (type IN ('expense', 'income')),
          icon TEXT DEFAULT 'ğŸ“¦',
          color TEXT DEFAULT '#1890FF',
          parent_category_id INTEGER DEFAULT 0,
          sort_order INTEGER DEFAULT 0,
          created_at TEXT NOT NULL,
          updated_at TEXT NOT NULL,
          is_deleted INTEGER DEFAULT 0 CHECK (is_deleted IN (0, 1)),
          UNIQUE (user_id, name, type)
        );
      `);
      // ç´¢å¼•
      await store.executeSql(`CREATE INDEX IF NOT EXISTS idx_categories_user_type ON categories (user_id, type) WHERE is_deleted = 0;`);
      await store.executeSql(`CREATE INDEX IF NOT EXISTS idx_categories_user_parent ON categories (user_id, parent_category_id) WHERE is_deleted = 0;`);
      await store.executeSql(`CREATE INDEX IF NOT EXISTS idx_categories_sort ON categories (user_id, sort_order, category_id);`);
      console.log('[CategoryDAO] åˆ†ç±»è¡¨å’Œç´¢å¼•åˆ›å»ºå®Œæˆ');
    } catch (error) {
      console.error('[CategoryDAO] åˆ›å»ºè¡¨æˆ–ç´¢å¼•å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] åˆ›å»ºè¡¨æˆ–ç´¢å¼•å¤±è´¥', error);
    }
  }

  /** æ’å…¥æ–°åˆ†ç±» */
  static async insert(category: Category): Promise<void> {
    if (!category.validate()) {
      throw new Error('[CategoryDAO] æ— æ•ˆåˆ†ç±»æ•°æ®');
    }
    const store = CategoryDAO.ensureDb();
    const now = new Date().toISOString();
    const sql = `
      INSERT INTO categories
        (user_id, name, type, icon, color, parent_category_id, sort_order, created_at, updated_at, is_deleted)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
    const params = [
      category.userId,
      category.name,
      category.type,
      category.icon,
      category.color,
      category.parentCategoryId,
      category.sortOrder,
      now,
      now,
      0
    ];
    try {
      await store.executeSql(sql, params);
      console.log(`[CategoryDAO] æ’å…¥æˆåŠŸ: ${category.name}`);
    } catch (error) {
      console.error('[CategoryDAO] æ’å…¥å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æ’å…¥å¤±è´¥', error);
    }
  }

  /** æ‰¹é‡æ’å…¥åˆ†ç±» */
  static async bulkInsert(categories: Category[]): Promise<void> {
    if (categories.length === 0) {
      return;
    }
    const store = CategoryDAO.ensureDb();
    await store.beginTransaction();
    try {
      const now = new Date().toISOString();
      const sql = `
        INSERT INTO categories
          (user_id, name, type, icon, color, parent_category_id, sort_order, created_at, updated_at, is_deleted)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `;
      
      for (const category of categories) {
        if (!category.validate()) {
          throw new Error(`[CategoryDAO] æ— æ•ˆåˆ†ç±»æ•°æ®: ${category.name}`);
        }
        const params = [
          category.userId,
          category.name,
          category.type,
          category.icon,
          category.color,
          category.parentCategoryId,
          category.sortOrder,
          now,
          now,
          0
        ];
        await store.executeSql(sql, params);
      }
      
      await store.commit();
      console.log(`[CategoryDAO] æ‰¹é‡æ’å…¥æˆåŠŸ: ${categories.length} æ¡`);
    } catch (error) {
      await store.rollBack();
      console.error('[CategoryDAO] æ‰¹é‡æ’å…¥å¤±è´¥: ' + JSON.stringify(error));
      throw error instanceof Error ? error : new Error(String(error));
    }
  }

  /** æ ¹æ® ID æŸ¥è¯¢åˆ†ç±»ï¼ˆåªè¿”å›æœªåˆ é™¤ï¼‰ */
  static async getById(userId: number, categoryId: number): Promise<Category | null> {
    const store = CategoryDAO.ensureDb();
    const sql = `SELECT * FROM categories WHERE category_id = ? AND user_id = ? AND is_deleted = 0`;
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [categoryId, userId]);
      if (!resultSet.goToNextRow()) return null;
      return CategoryDAO.mapRowToCategory(resultSet);
    } catch (error) {
      console.error('[CategoryDAO] æŸ¥è¯¢å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æŸ¥è¯¢å¤±è´¥', error);
    } finally {
      resultSet?.close();
    }
  }

  /** æŸ¥è¯¢ç”¨æˆ·æ‰€æœ‰æœªåˆ é™¤åˆ†ç±» */
  static async getAll(userId: number): Promise<Category[]> {
    const store = CategoryDAO.ensureDb();
    const sql = `SELECT * FROM categories WHERE user_id = ? AND is_deleted = 0 ORDER BY sort_order ASC, category_id ASC`;
    const categories: Category[] = [];
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [userId]);
      while (resultSet.goToNextRow()) {
        categories.push(CategoryDAO.mapRowToCategory(resultSet));
      }
      return categories;
    } catch (error) {
      console.error('[CategoryDAO] æŸ¥è¯¢å…¨éƒ¨å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æŸ¥è¯¢å…¨éƒ¨å¤±è´¥', error);
    } finally {
      resultSet?.close();
    }
  }

  /** æŒ‰ç±»å‹æŸ¥è¯¢ï¼ˆæ”¶å…¥/æ”¯å‡ºï¼‰ */
  static async getByType(userId: number, type: 'expense' | 'income'): Promise<Category[]> {
    const store = CategoryDAO.ensureDb();
    const sql = `SELECT * FROM categories WHERE user_id = ? AND type = ? AND is_deleted = 0 ORDER BY sort_order ASC, category_id ASC`;
    const categories: Category[] = [];
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [userId, type]);
      while (resultSet.goToNextRow()) {
        categories.push(CategoryDAO.mapRowToCategory(resultSet));
      }
      return categories;
    } catch (error) {
      console.error('[CategoryDAO] æŒ‰ç±»å‹æŸ¥è¯¢å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æŒ‰ç±»å‹æŸ¥è¯¢å¤±è´¥', error);
    } finally {
      resultSet?.close();
    }
  }

  /** è·å–æŸä¸ªçˆ¶åˆ†ç±»çš„å­åˆ†ç±» */
  static async getChildren(userId: number, parentId: number): Promise<Category[]> {
    const store = CategoryDAO.ensureDb();
    const sql = `SELECT * FROM categories WHERE user_id = ? AND parent_category_id = ? AND is_deleted = 0 ORDER BY sort_order ASC, category_id ASC`;
    const categories: Category[] = [];
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [userId, parentId]);
      while (resultSet.goToNextRow()) {
        categories.push(CategoryDAO.mapRowToCategory(resultSet));
      }
      return categories;
    } catch (error) {
      console.error('[CategoryDAO] æŸ¥è¯¢å­åˆ†ç±»å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æŸ¥è¯¢å­åˆ†ç±»å¤±è´¥', error);
    } finally {
      resultSet?.close();
    }
  }

  /** æ›´æ–°åˆ†ç±»ä¿¡æ¯ */
  static async update(category: Category): Promise<void> {
    if (!category.validate()) {
      throw new Error('[CategoryDAO] æ— æ•ˆåˆ†ç±»æ•°æ®');
    }
    const store = CategoryDAO.ensureDb();
    const now = new Date().toISOString();
    const sql = `
      UPDATE categories
      SET name = ?, type = ?, icon = ?, color = ?, parent_category_id = ?, sort_order = ?, updated_at = ?, is_deleted = ?
      WHERE category_id = ? AND user_id = ?
    `;
    const params = [
      category.name,
      category.type,
      category.icon,
      category.color,
      category.parentCategoryId,
      category.sortOrder,
      now,
      category.is_deleted,
      category.categoryId,
      category.userId
    ];
    try {
      await store.executeSql(sql, params);
      console.log(`[CategoryDAO] æ›´æ–°æˆåŠŸ: ${category.name}`);
    } catch (error) {
      console.error('[CategoryDAO] æ›´æ–°å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æ›´æ–°å¤±è´¥', error);
    }
  }

  /** è½¯åˆ é™¤åˆ†ç±» */
  static async softDelete(userId: number, categoryId: number): Promise<void> {
    const store = CategoryDAO.ensureDb();
    const now = new Date().toISOString();
    const sql = `UPDATE categories SET is_deleted = 1, updated_at = ? WHERE category_id = ? AND user_id = ?`;
    try {
      await store.executeSql(sql, [now, categoryId, userId]);
      console.log(`[CategoryDAO] è½¯åˆ é™¤æˆåŠŸ: category_id=${categoryId}`);
    } catch (error) {
      console.error('[CategoryDAO] è½¯åˆ é™¤å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] è½¯åˆ é™¤å¤±è´¥', error);
    }
  }

  /** æ¢å¤å·²åˆ é™¤åˆ†ç±» */
  static async restore(userId: number, categoryId: number): Promise<void> {
    const store = CategoryDAO.ensureDb();
    const now = new Date().toISOString();
    const sql = `UPDATE categories SET is_deleted = 0, updated_at = ? WHERE category_id = ? AND user_id = ?`;
    try {
      await store.executeSql(sql, [now, categoryId, userId]);
      console.log(`[CategoryDAO] æ¢å¤æˆåŠŸ: category_id=${categoryId}`);
    } catch (error) {
      console.error('[CategoryDAO] æ¢å¤å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] æ¢å¤å¤±è´¥', error);
    }
  }

  /** çœŸåˆ é™¤åˆ†ç±»ï¼ˆæ…ç”¨ï¼‰ */
  static async hardDelete(userId: number, categoryId: number): Promise<void> {
    const store = CategoryDAO.ensureDb();
    const sql = `DELETE FROM categories WHERE category_id = ? AND user_id = ?`;
    try {
      await store.executeSql(sql, [categoryId, userId]);
      console.log(`[CategoryDAO] ç¡¬åˆ é™¤æˆåŠŸ: category_id=${categoryId}`);
    } catch (error) {
      console.error('[CategoryDAO] åˆ é™¤å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] åˆ é™¤å¤±è´¥', error);
    }
  }

  /**
   * è·å–åˆ†ç±»æ ‘ï¼ˆåŒ…å«å­åˆ†ç±»ï¼‰
   * @param userId ç”¨æˆ·ID
   * @param type åˆ†ç±»ç±»å‹
   * @returns åˆ†ç±»æ ‘ç»“æ„
   */
  static async getCategoryTree(userId: number, type: 'expense' | 'income'): Promise<CategoryTreeNode[]> {
    const store = CategoryDAO.ensureDb();
    const sql = `
      SELECT * FROM categories 
      WHERE user_id = ? AND type = ? AND is_deleted = 0 
      ORDER BY sort_order ASC, category_id ASC
    `;
    
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [userId, type]);
      const allCategories: Category[] = [];
      
      while (resultSet.goToNextRow()) {
        allCategories.push(CategoryDAO.mapRowToCategory(resultSet));
      }
      
      // æ„å»ºæ ‘ç»“æ„
      return CategoryDAO.buildCategoryTree(allCategories);
    } catch (error) {
      console.error('[CategoryDAO] è·å–åˆ†ç±»æ ‘å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] è·å–åˆ†ç±»æ ‘å¤±è´¥', error);
    } finally {
      resultSet?.close();
    }
  }

  /**
   * æ„å»ºåˆ†ç±»æ ‘ç»“æ„
   * @param categories åˆ†ç±»åˆ—è¡¨
   * @returns åˆ†ç±»æ ‘èŠ‚ç‚¹æ•°ç»„
   */
  private static buildCategoryTree(categories: Category[]): CategoryTreeNode[] {
    const map = new Map<number, CategoryTreeNode>();
    const roots: CategoryTreeNode[] = [];
    
    // åˆå§‹åŒ–èŠ‚ç‚¹
    categories.forEach(cat => {
      map.set(cat.categoryId, {
        category: cat,
        children: []
      });
    });
    
    // æ„å»ºçˆ¶å­å…³ç³»
    categories.forEach(cat => {
      const node = map.get(cat.categoryId);
      if (node) {
        if (cat.parentCategoryId === 0) {
          roots.push(node);
        } else {
          const parent = map.get(cat.parentCategoryId);
          if (parent) {
            parent.children.push(node);
          }
        }
      }
    });
    
    return roots;
  }

  /**
   * æŒ‰åˆ†ç±»èšåˆç»Ÿè®¡
   * @param userId ç”¨æˆ·ID
   * @param startDate å¼€å§‹æ—¥æœŸ
   * @param endDate ç»“æŸæ—¥æœŸ
   * @returns åˆ†ç±»ç»Ÿè®¡ç»“æœ
   */
  static async aggregateByCategory(
    userId: number,
    startDate: string,
    endDate: string
  ): Promise<CategoryAggregation[]> {
    const store = CategoryDAO.ensureDb();
    
    const sql = `
      SELECT 
        c.category_id,
        c.name AS category_name,
        c.type,
        c.icon,
        c.color,
        c.parent_category_id,
        COUNT(b.bill_id) AS transaction_count,
        COALESCE(SUM(b.amount), 0) AS total_amount,
        COALESCE(AVG(b.amount), 0) AS avg_amount,
        COALESCE(MIN(b.amount), 0) AS min_amount,
        COALESCE(MAX(b.amount), 0) AS max_amount
      FROM categories c
      LEFT JOIN bills b ON c.category_id = b.category_id 
        AND b.is_deleted = 0
        AND b.transaction_date >= ?
        AND b.transaction_date <= ?
      INNER JOIN accounts a ON b.account_id = a.account_id
      WHERE c.user_id = ? AND c.is_deleted = 0 AND a.user_id = ?
      GROUP BY c.category_id
      ORDER BY total_amount DESC
    `;
    
    let resultSet: relationalStore.ResultSet | null = null;
    try {
      resultSet = await store.querySql(sql, [startDate, endDate, userId, userId]);
      const results: CategoryAggregation[] = [];
      
      while (resultSet.goToNextRow()) {
        results.push({
          categoryId: resultSet.getLong(resultSet.getColumnIndex('category_id')),
          categoryName: resultSet.getString(resultSet.getColumnIndex('category_name')),
          type: resultSet.getString(resultSet.getColumnIndex('type')) as 'expense' | 'income',
          icon: resultSet.getString(resultSet.getColumnIndex('icon')),
          color: resultSet.getString(resultSet.getColumnIndex('color')),
          parentCategoryId: resultSet.getLong(resultSet.getColumnIndex('parent_category_id')),
          transactionCount: resultSet.getLong(resultSet.getColumnIndex('transaction_count')),
          totalAmount: resultSet.getDouble(resultSet.getColumnIndex('total_amount')),
          avgAmount: resultSet.getDouble(resultSet.getColumnIndex('avg_amount')),
          minAmount: resultSet.getDouble(resultSet.getColumnIndex('min_amount')),
          maxAmount: resultSet.getDouble(resultSet.getColumnIndex('max_amount'))
        });
      }
      
      return results;
    } catch (error) {
      console.error('[CategoryDAO] åˆ†ç±»èšåˆç»Ÿè®¡å¤±è´¥: ' + JSON.stringify(error));
      throw CategoryDAO.toError('[CategoryDAO] åˆ†ç±»èšåˆç»Ÿè®¡å¤±è´¥', error);
    } finally {
      resultSet?.close();
    }
  }

  static async exists(categoryId: number): Promise<boolean> {
    const sql = `SELECT 1 FROM categories WHERE category_id = ? AND is_deleted = 0`;
    const store = CategoryDAO.ensureDb();
    let rs: relationalStore.ResultSet | null = null;
    try {
      rs = await store.querySql(sql, [categoryId]);
      return rs.goToNextRow();
    } finally {
      if (rs) rs.close();
    }
  }

  /** ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ– */
  private static ensureDb(): relationalStore.RdbStore {
    if (!db) {
      throw new Error('[CategoryDAO] Database has not been initialized. Call initDatabase first.');
    }
    return db;
  }

  /** ç»Ÿä¸€é”™è¯¯è½¬æ¢ */
  private static toError(message: string, err: Error | string | Record<string, Object>): Error {
    let details = '';
    try {
      details = typeof err === 'string' ? err : JSON.stringify(err);
    } catch (_) {
      details = '';
    }
    return new Error(`${message}${details ? ' -> ' + details : ''}`);
  }

  /** å°†æŸ¥è¯¢ç»“æœæ˜ å°„ä¸º Category å®ä¾‹ */
  private static mapRowToCategory(resultSet: relationalStore.ResultSet): Category {
    const category = new Category();
    category.categoryId = resultSet.getLong(resultSet.getColumnIndex('category_id'));
    category.userId = resultSet.getLong(resultSet.getColumnIndex('user_id'));
    category.name = resultSet.getString(resultSet.getColumnIndex('name'));
    category.type = resultSet.getString(resultSet.getColumnIndex('type')) as 'expense' | 'income';
    category.icon = resultSet.getString(resultSet.getColumnIndex('icon'));
    category.color = resultSet.getString(resultSet.getColumnIndex('color'));
    category.parentCategoryId = resultSet.getLong(resultSet.getColumnIndex('parent_category_id'));
    category.sortOrder = resultSet.getLong(resultSet.getColumnIndex('sort_order'));
    category.createdAt = resultSet.getString(resultSet.getColumnIndex('created_at'));
    category.updatedAt = resultSet.getString(resultSet.getColumnIndex('updated_at'));
    category.is_deleted = resultSet.getLong(resultSet.getColumnIndex('is_deleted'));
    return category;
  }
}
