# 导出/备份接口与加密逻辑技术文档

## 1. 概述

本文档详细说明基于 ArkTS 的数据导出、备份接口设计以及数据加密逻辑实现方案。适用于 HarmonyOS 应用中的数据安全和迁移功能。

## 2. 功能需求

### 2.1 核心功能
- 数据完整导出（JSON/CSV 格式）
- 数据加密备份（AES-256-GCM）
- 数据导入恢复
- 增量备份支持
- 云端同步备份

### 2.2 安全要求
- 敏感数据加密存储
- 备份文件加密传输
- 密钥安全管理
- 数据完整性校验

## 3. 数据导出接口设计

### 3.1 导出数据模型

```typescript
/**
 * 导出数据结构
 */
export interface ExportData {
  version: string;              // 数据版本号
  exportTime: string;           // 导出时间
  userId: number;               // 用户ID
  checksum: string;             // 数据校验和
  data: {
    users: User[];
    accounts: Account[];
    categories: Category[];
    bills: Bill[];
    budgets: Budget[];
    tags: Tag[];
    billTags: BillTag[];
  };
}

/**
 * 导出配置
 */
export interface ExportOptions {
  format: 'json' | 'csv';       // 导出格式
  encrypt: boolean;             // 是否加密
  password?: string;            // 加密密码
  includeDeleted: boolean;      // 是否包含已删除数据
  dateRange?: {                 // 日期范围
    startDate: string;
    endDate: string;
  };
}
```

### 3.2 导出服务实现

```typescript
import cryptoFramework from '@ohos.security.cryptoFramework';
import fs from '@ohos.file.fs';

export class ExportService {
  private static readonly EXPORT_VERSION = '1.0.0';
  private static readonly CHUNK_SIZE = 1024 * 1024; // 1MB
  
  /**
   * 导出用户所有数据
   */
  static async exportAllData(
    userId: number,
    options: ExportOptions
  ): Promise<string> {
    try {
      // 1. 收集数据
      const exportData = await this.collectUserData(userId, options);
      
      // 2. 生成校验和
      exportData.checksum = await this.generateChecksum(exportData.data);
      
      // 3. 序列化数据
      let content: string;
      if (options.format === 'json') {
        content = JSON.stringify(exportData, null, 2);
      } else {
        content = await this.convertToCSV(exportData);
      }
      
      // 4. 加密（如果需要）
      if (options.encrypt && options.password) {
        content = await this.encryptData(content, options.password);
      }
      
      // 5. 保存文件
      const filePath = await this.saveToFile(content, userId, options);
      
      console.log(`[ExportService] 数据导出成功: ${filePath}`);
      return filePath;
    } catch (error) {
      console.error('[ExportService] 导出失败:', error);
      throw error;
    }
  }
}
```


  /**
   * 收集用户数据
   */
  private static async collectUserData(
    userId: number,
    options: ExportOptions
  ): Promise<ExportData> {
    const data: ExportData = {
      version: this.EXPORT_VERSION,
      exportTime: new Date().toISOString(),
      userId: userId,
      checksum: '',
      data: {
        users: [],
        accounts: [],
        categories: [],
        bills: [],
        budgets: [],
        tags: [],
        billTags: []
      }
    };
    
    // 查询用户信息
    const user = await UserDAO.getById(userId);
    if (user) {
      data.data.users = [user];
    }
    
    // 查询账户
    data.data.accounts = await AccountDAO.getAll(userId);
    
    // 查询分类
    data.data.categories = await CategoryDAO.getAll(userId);
    
    // 查询账单（支持日期范围）
    if (options.dateRange) {
      data.data.bills = await BillDAO.getByDateRange(
        userId,
        options.dateRange.startDate,
        options.dateRange.endDate
      );
    } else {
      data.data.bills = await BillDAO.getAll(userId);
    }
    
    // 查询预算
    data.data.budgets = await BudgetDAO.getAll(userId);
    
    // 查询标签
    data.data.tags = await TagDAO.getAll(userId);
    
    // 查询账单-标签关联
    data.data.billTags = await TagDAO.getAllBillTags(userId);
    
    return data;
  }

  /**
   * 生成数据校验和（SHA-256）
   */
  private static async generateChecksum(data: any): Promise<string> {
    try {
      const md = cryptoFramework.createMd('SHA256');
      const dataStr = JSON.stringify(data);
      const input: cryptoFramework.DataBlob = {
        data: new Uint8Array(Buffer.from(dataStr, 'utf-8'))
      };
      
      await md.update(input);
      const hashOutput = await md.digest();
      
      // 转换为十六进制字符串
      return Array.from(hashOutput.data)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    } catch (error) {
      console.error('[ExportService] 生成校验和失败:', error);
      throw error;
    }
  }

  /**
   * 保存到文件
   */
  private static async saveToFile(
    content: string,
    userId: number,
    options: ExportOptions
  ): Promise<string> {
    const timestamp = new Date().getTime();
    const extension = options.encrypt ? 'enc' : options.format;
    const fileName = `backup_${userId}_${timestamp}.${extension}`;
    
    // 获取应用文件目录
    const context = getContext(this);
    const filesDir = context.filesDir;
    const filePath = `${filesDir}/exports/${fileName}`;
    
    // 确保目录存在
    await fs.mkdir(`${filesDir}/exports`, true);
    
    // 写入文件
    const file = fs.openSync(filePath, fs.OpenMode.CREATE | fs.OpenMode.WRITE_ONLY);
    fs.writeSync(file.fd, content);
    fs.closeSync(file);
    
    return filePath;
  }

## 4. 数据加密实现

### 4.1 加密算法选择

使用 AES-256-GCM 模式：
- 对称加密算法，性能优秀
- GCM 模式提供认证加密（AEAD）
- 同时保证数据机密性和完整性

### 4.2 密钥派生（PBKDF2）

```typescript
/**
 * 从密码派生加密密钥
 * @param password 用户密码
 * @param salt 盐值（随机生成）
 * @returns 派生的密钥
 */
private static async deriveKey(
  password: string,
  salt: Uint8Array
): Promise<cryptoFramework.SymKey> {
  try {
    // 创建 PBKDF2 密钥派生器
    const kdf = cryptoFramework.createKdf('PBKDF2|SHA256|100000|32');
    
    const spec: cryptoFramework.PBKDF2Spec = {
      algName: 'PBKDF2',
      password: new Uint8Array(Buffer.from(password, 'utf-8')),
      salt: salt,
      iterations: 100000,  // 迭代次数
      keySize: 32          // 256 bits
    };
    
    const keyBlob = await kdf.generateSecret(spec);
    
    // 转换为对称密钥
    const symKeyGenerator = cryptoFramework.createSymKeyGenerator('AES256');
    return await symKeyGenerator.convertKey(keyBlob);
  } catch (error) {
    console.error('[ExportService] 密钥派生失败:', error);
    throw error;
  }
}
```

### 4.3 数据加密

```typescript
/**
 * 加密数据
 * @param plaintext 明文数据
 * @param password 加密密码
 * @returns 加密后的数据（Base64编码）
 */
private static async encryptData(
  plaintext: string,
  password: string
): Promise<string> {
  try {
    // 1. 生成随机盐值和 IV
    const salt = cryptoFramework.createRandom().generateRandom(16);
    const iv = cryptoFramework.createRandom().generateRandom(12); // GCM 推荐 12 字节
    
    // 2. 派生密钥
    const key = await this.deriveKey(password, salt.data);
    
    // 3. 创建加密器
    const cipher = cryptoFramework.createCipher('AES256|GCM|PKCS7');
    const gcmParams: cryptoFramework.GcmParamsSpec = {
      iv: { data: iv.data },
      aad: { data: new Uint8Array(0) },  // 附加认证数据（可选）
      authTag: { data: new Uint8Array(16) }  // 认证标签
    };
    
    await cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, key, gcmParams);
    
    // 4. 加密数据
    const input: cryptoFramework.DataBlob = {
      data: new Uint8Array(Buffer.from(plaintext, 'utf-8'))
    };
    
    const encrypted = await cipher.doFinal(input);
    
    // 5. 组合数据：salt(16) + iv(12) + authTag(16) + ciphertext
    const result = new Uint8Array(
      salt.data.length + 
      iv.data.length + 
      gcmParams.authTag.data.length + 
      encrypted.data.length
    );
    
    let offset = 0;
    result.set(salt.data, offset);
    offset += salt.data.length;
    result.set(iv.data, offset);
    offset += iv.data.length;
    result.set(gcmParams.authTag.data, offset);
    offset += gcmParams.authTag.data.length;
    result.set(encrypted.data, offset);
    
    // 6. Base64 编码
    return Buffer.from(result).toString('base64');
  } catch (error) {
    console.error('[ExportService] 加密失败:', error);
    throw error;
  }
}
```

### 4.4 数据解密

```typescript
/**
 * 解密数据
 * @param ciphertext 密文数据（Base64编码）
 * @param password 解密密码
 * @returns 解密后的明文
 */
private static async decryptData(
  ciphertext: string,
  password: string
): Promise<string> {
  try {
    // 1. Base64 解码
    const encryptedData = new Uint8Array(Buffer.from(ciphertext, 'base64'));
    
    // 2. 提取 salt、IV、authTag 和密文
    let offset = 0;
    const salt = encryptedData.slice(offset, offset + 16);
    offset += 16;
    const iv = encryptedData.slice(offset, offset + 12);
    offset += 12;
    const authTag = encryptedData.slice(offset, offset + 16);
    offset += 16;
    const encrypted = encryptedData.slice(offset);
    
    // 3. 派生密钥
    const key = await this.deriveKey(password, salt);
    
    // 4. 创建解密器
    const decipher = cryptoFramework.createCipher('AES256|GCM|PKCS7');
    const gcmParams: cryptoFramework.GcmParamsSpec = {
      iv: { data: iv },
      aad: { data: new Uint8Array(0) },
      authTag: { data: authTag }
    };
    
    await decipher.init(cryptoFramework.CryptoMode.DECRYPT_MODE, key, gcmParams);
    
    // 5. 解密数据
    const input: cryptoFramework.DataBlob = { data: encrypted };
    const decrypted = await decipher.doFinal(input);
    
    // 6. 转换为字符串
    return Buffer.from(decrypted.data).toString('utf-8');
  } catch (error) {
    console.error('[ExportService] 解密失败:', error);
    throw new Error('解密失败，密码可能不正确');
  }
}
```

## 5. 数据导入接口

### 5.1 导入服务实现

```typescript
export class ImportService {
  /**
   * 导入数据
   * @param filePath 文件路径
   * @param password 解密密码（如果文件已加密）
   * @param options 导入选项
   */
  static async importData(
    filePath: string,
    password?: string,
    options?: ImportOptions
  ): Promise<ImportResult> {
    try {
      // 1. 读取文件
      let content = await this.readFile(filePath);
      
      // 2. 解密（如果需要）
      if (password) {
        content = await ExportService.decryptData(content, password);
      }
      
      // 3. 解析数据
      const exportData: ExportData = JSON.parse(content);
      
      // 4. 验证数据完整性
      const isValid = await this.validateData(exportData);
      if (!isValid) {
        throw new Error('数据校验失败，文件可能已损坏');
      }
      
      // 5. 导入数据
      const result = await this.importToDatabase(exportData, options);
      
      console.log('[ImportService] 数据导入成功');
      return result;
    } catch (error) {
      console.error('[ImportService] 导入失败:', error);
      throw error;
    }
  }

  /**
   * 验证数据完整性
   */
  private static async validateData(exportData: ExportData): Promise<boolean> {
    try {
      const calculatedChecksum = await ExportService.generateChecksum(exportData.data);
      return calculatedChecksum === exportData.checksum;
    } catch (error) {
      console.error('[ImportService] 数据验证失败:', error);
      return false;
    }
  }

  /**
   * 导入到数据库
   */
  private static async importToDatabase(
    exportData: ExportData,
    options?: ImportOptions
  ): Promise<ImportResult> {
    const result: ImportResult = {
      success: true,
      imported: {
        users: 0,
        accounts: 0,
        categories: 0,
        bills: 0,
        budgets: 0,
        tags: 0
      },
      errors: []
    };
    
    const store = DatabaseManager.getDatabase();
    await store.beginTransaction();
    
    try {
      // 导入用户
      for (const user of exportData.data.users) {
        try {
          await UserDAO.insert(user);
          result.imported.users++;
        } catch (error) {
          result.errors.push(`用户导入失败: ${error}`);
        }
      }
      
      // 导入账户
      for (const account of exportData.data.accounts) {
        try {
          await AccountDAO.insert(account);
          result.imported.accounts++;
        } catch (error) {
          result.errors.push(`账户导入失败: ${error}`);
        }
      }
      
      // 导入分类
      for (const category of exportData.data.categories) {
        try {
          await CategoryDAO.insert(category);
          result.imported.categories++;
        } catch (error) {
          result.errors.push(`分类导入失败: ${error}`);
        }
      }
      
      // 导入账单
      for (const bill of exportData.data.bills) {
        try {
          await BillDAO.insert(bill);
          result.imported.bills++;
        } catch (error) {
          result.errors.push(`账单导入失败: ${error}`);
        }
      }
      
      // 导入预算
      for (const budget of exportData.data.budgets) {
        try {
          await BudgetDAO.insert(budget);
          result.imported.budgets++;
        } catch (error) {
          result.errors.push(`预算导入失败: ${error}`);
        }
      }
      
      // 导入标签
      for (const tag of exportData.data.tags) {
        try {
          await TagDAO.insert(tag);
          result.imported.tags++;
        } catch (error) {
          result.errors.push(`标签导入失败: ${error}`);
        }
      }
      
      // 导入账单-标签关联
      for (const billTag of exportData.data.billTags) {
        try {
          await TagDAO.addTagToBill(billTag.billId, billTag.tagId);
        } catch (error) {
          result.errors.push(`标签关联导入失败: ${error}`);
        }
      }
      
      await store.commit();
      console.log('[ImportService] 数据导入完成');
    } catch (error) {
      await store.rollBack();
      result.success = false;
      result.errors.push(`事务失败: ${error}`);
      throw error;
    }
    
    return result;
  }
}
```

## 6. 增量备份实现

### 6.1 备份元数据表

```sql
CREATE TABLE IF NOT EXISTS backup_metadata (
  backup_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  backup_type TEXT NOT NULL CHECK (backup_type IN ('full', 'incremental')),
  backup_time TEXT NOT NULL,
  file_path TEXT NOT NULL,
  file_size INTEGER NOT NULL,
  checksum TEXT NOT NULL,
  is_encrypted INTEGER DEFAULT 0,
  last_modified_time TEXT,
  status TEXT DEFAULT 'completed',
  FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 6.2 增量备份逻辑

```typescript
export class IncrementalBackupService {
  /**
   * 执行增量备份
   */
  static async performIncrementalBackup(
    userId: number,
    lastBackupTime: string,
    options: ExportOptions
  ): Promise<string> {
    try {
      // 查询自上次备份后修改的数据
      const changedData = await this.getChangedData(userId, lastBackupTime);
      
      const exportData: ExportData = {
        version: ExportService.EXPORT_VERSION,
        exportTime: new Date().toISOString(),
        userId: userId,
        checksum: '',
        data: changedData
      };
      
      exportData.checksum = await ExportService.generateChecksum(changedData);
      
      // 保存增量备份
      const filePath = await this.saveIncrementalBackup(exportData, options);
      
      // 记录备份元数据
      await this.recordBackupMetadata(userId, filePath, 'incremental');
      
      return filePath;
    } catch (error) {
      console.error('[IncrementalBackup] 增量备份失败:', error);
      throw error;
    }
  }

  /**
   * 获取变更数据
   */
  private static async getChangedData(
    userId: number,
    lastBackupTime: string
  ): Promise<any> {
    const store = DatabaseManager.getDatabase();
    
    // 查询修改时间晚于上次备份的数据
    const data = {
      users: [],
      accounts: [],
      categories: [],
      bills: [],
      budgets: [],
      tags: [],
      billTags: []
    };
    
    // 账户变更
    const accountSql = `
      SELECT * FROM accounts 
      WHERE user_id = ? AND updated_at > ?
    `;
    let rs = await store.querySql(accountSql, [userId, lastBackupTime]);
    while (rs.goToNextRow()) {
      data.accounts.push(AccountDAO.mapRowToAccount(rs));
    }
    rs.close();
    
    // 分类变更
    const categorySql = `
      SELECT * FROM categories 
      WHERE user_id = ? AND updated_at > ?
    `;
    rs = await store.querySql(categorySql, [userId, lastBackupTime]);
    while (rs.goToNextRow()) {
      data.categories.push(CategoryDAO.mapRowToCategory(rs));
    }
    rs.close();
    
    // 账单变更
    const billSql = `
      SELECT b.* FROM bills b
      INNER JOIN accounts a ON b.account_id = a.account_id
      WHERE a.user_id = ? AND b.updated_at > ?
    `;
    rs = await store.querySql(billSql, [userId, lastBackupTime]);
    while (rs.goToNextRow()) {
      data.bills.push(BillDAO.mapRowToBill(rs));
    }
    rs.close();
    
    // 其他表类似处理...
    
    return data;
  }
}
```

## 7. 云端同步备份

### 7.1 云存储接口

```typescript
export interface CloudStorageProvider {
  /**
   * 上传备份文件
   */
  upload(filePath: string, remotePath: string): Promise<string>;
  
  /**
   * 下载备份文件
   */
  download(remotePath: string, localPath: string): Promise<void>;
  
  /**
   * 列出备份文件
   */
  list(userId: number): Promise<CloudBackupFile[]>;
  
  /**
   * 删除备份文件
   */
  delete(remotePath: string): Promise<void>;
}
```

### 7.2 华为云 OBS 实现示例

```typescript
import request from '@ohos.request';

export class HuaweiCloudStorage implements CloudStorageProvider {
  private endpoint: string;
  private accessKey: string;
  private secretKey: string;
  private bucketName: string;
  
  async upload(filePath: string, remotePath: string): Promise<string> {
    try {
      const uploadConfig: request.UploadConfig = {
        url: `${this.endpoint}/${this.bucketName}/${remotePath}`,
        header: this.generateAuthHeaders('PUT', remotePath),
        method: 'PUT',
        files: [{ filename: 'backup', name: 'file', uri: `internal://cache/${filePath}`, type: 'file' }],
        data: []
      };
      
      const uploadTask = await request.uploadFile(getContext(this), uploadConfig);
      
      return new Promise((resolve, reject) => {
        uploadTask.on('complete', () => {
          console.log('[CloudStorage] 上传成功');
          resolve(remotePath);
        });
        
        uploadTask.on('fail', (err) => {
          console.error('[CloudStorage] 上传失败:', err);
          reject(err);
        });
      });
    } catch (error) {
      console.error('[CloudStorage] 上传异常:', error);
      throw error;
    }
  }
  
  private generateAuthHeaders(method: string, path: string): Record<string, string> {
    // 实现华为云 OBS 签名算法
    // 参考：https://support.huaweicloud.com/api-obs/obs_04_0010.html
    const date = new Date().toUTCString();
    const signature = this.calculateSignature(method, path, date);
    
    return {
      'Date': date,
      'Authorization': `OBS ${this.accessKey}:${signature}`,
      'Content-Type': 'application/octet-stream'
    };
  }
}
```

## 8. 安全最佳实践

### 8.1 密码管理
- 不在代码中硬编码密码
- 使用用户输入的密码进行加密
- 支持密码强度验证
- 提供密码找回机制

### 8.2 密钥存储
- 使用 HarmonyOS HUKS（密钥管理服务）
- 密钥不离开安全环境
- 定期轮换密钥

### 8.3 传输安全
- 使用 HTTPS 传输备份文件
- 实现证书固定（Certificate Pinning）
- 验证服务器证书

### 8.4 访问控制
- 备份文件权限控制
- 用户身份验证
- 操作日志记录

## 9. 使用示例

### 9.1 导出加密备份

```typescript
const options: ExportOptions = {
  format: 'json',
  encrypt: true,
  password: 'user_password_123',
  includeDeleted: false,
  dateRange: {
    startDate: '2025-01-01',
    endDate: '2025-12-31'
  }
};

const filePath = await ExportService.exportAllData(userId, options);
console.log(`备份文件已保存: ${filePath}`);
```

### 9.2 导入备份

```typescript
const result = await ImportService.importData(
  filePath,
  'user_password_123'
);

if (result.success) {
  console.log('导入成功:', result.imported);
} else {
  console.error('导入失败:', result.errors);
}
```

### 9.3 云端备份

```typescript
// 导出并上传到云端
const localPath = await ExportService.exportAllData(userId, options);
const cloudStorage = new HuaweiCloudStorage(config);
const remotePath = await cloudStorage.upload(localPath, `backups/user_${userId}/backup.enc`);
console.log(`云端备份完成: ${remotePath}`);
```

## 10. 性能优化

### 10.1 大文件处理
- 分块读写，避免内存溢出
- 使用流式处理
- 压缩数据减少文件大小

### 10.2 并发控制
- 限制同时导出/导入任务数
- 使用队列管理备份任务
- 后台任务处理

### 10.3 进度反馈
- 实时显示导出/导入进度
- 支持取消操作
- 错误重试机制

---

**文档版本**: v1.0  
**最后更新**: 2025-11-10  
**适用平台**: HarmonyOS (ArkTS)
