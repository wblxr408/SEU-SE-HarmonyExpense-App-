# ç´¢å¼•ä¼˜åŒ–ä¸æ‰¹é‡æŸ¥è¯¢æŠ€æœ¯æ–‡æ¡£

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜åŸºäº ArkTS å’Œ HarmonyOS å…³ç³»å‹æ•°æ®åº“çš„ç´¢å¼•ä¼˜åŒ–ç­–ç•¥å’Œæ‰¹é‡æŸ¥è¯¢å®ç°æ–¹æ¡ˆï¼Œæ—¨åœ¨æå‡åº”ç”¨æ•°æ®åº“æ€§èƒ½å’Œå“åº”é€Ÿåº¦ã€‚

## 2. ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

### 2.1 ç´¢å¼•è®¾è®¡åŸåˆ™

#### 2.1.1 é€‰æ‹©æ€§åŸåˆ™
- ä¸ºé«˜é€‰æ‹©æ€§å­—æ®µåˆ›å»ºç´¢å¼•ï¼ˆå”¯ä¸€å€¼å¤šçš„å­—æ®µï¼‰
- é¿å…ä¸ºä½é€‰æ‹©æ€§å­—æ®µåˆ›å»ºç´¢å¼•ï¼ˆå¦‚æ€§åˆ«ã€çŠ¶æ€ç­‰ï¼‰

#### 2.1.2 æŸ¥è¯¢é¢‘ç‡åŸåˆ™
- ä¼˜å…ˆä¸ºé«˜é¢‘æŸ¥è¯¢å­—æ®µåˆ›å»ºç´¢å¼•
- WHEREã€JOINã€ORDER BY å­å¥ä¸­çš„å­—æ®µ

#### 2.1.3 å¤åˆç´¢å¼•åŸåˆ™
- éµå¾ªæœ€å·¦å‰ç¼€åŒ¹é…è§„åˆ™
- å°†é€‰æ‹©æ€§é«˜çš„å­—æ®µæ”¾åœ¨å‰é¢
- è€ƒè™‘æŸ¥è¯¢è¦†ç›–ç´¢å¼•

#### 2.1.4 ç´¢å¼•ç»´æŠ¤æˆæœ¬
- å¹³è¡¡æŸ¥è¯¢æ€§èƒ½å’Œå†™å…¥æ€§èƒ½
- é¿å…è¿‡å¤šç´¢å¼•å½±å“ INSERT/UPDATE æ€§èƒ½

### 2.2 æ ¸å¿ƒè¡¨ç´¢å¼•è®¾è®¡

#### 2.2.1 Users è¡¨ç´¢å¼•

```sql
-- ä¸»é”®ç´¢å¼•ï¼ˆè‡ªåŠ¨åˆ›å»ºï¼‰
CREATE TABLE users (
  user_id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT NOT NULL,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  is_deleted INTEGER DEFAULT 0
);

-- å”¯ä¸€ç´¢å¼•ï¼ˆé‚®ç®±ç™»å½•ï¼‰
CREATE UNIQUE INDEX IF NOT EXISTS idx_users_email 
ON users (email) WHERE is_deleted = 0;

-- ç”¨æˆ·åç´¢å¼•ï¼ˆç”¨æˆ·åæœç´¢ï¼‰
CREATE INDEX IF NOT EXISTS idx_users_username 
ON users (username) WHERE is_deleted = 0;
```

#### 2.2.2 Accounts è¡¨ç´¢å¼•

```sql
CREATE TABLE accounts (
  account_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  name TEXT NOT NULL,
  type TEXT NOT NULL,
  balance REAL NOT NULL DEFAULT 0,
  color TEXT NOT NULL DEFAULT '#1890FF',
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  is_deleted INTEGER DEFAULT 0,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- ç”¨æˆ·è´¦æˆ·æŸ¥è¯¢ï¼ˆé«˜é¢‘ï¼‰
CREATE INDEX IF NOT EXISTS idx_accounts_user 
ON accounts (user_id) WHERE is_deleted = 0;

-- ç”¨æˆ·+ç±»å‹å¤åˆç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_accounts_user_type 
ON accounts (user_id, type) WHERE is_deleted = 0;

-- ä½™é¢æ’åºç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_accounts_balance 
ON accounts (user_id, balance DESC) WHERE is_deleted = 0;
```


#### 2.2.3 Categories è¡¨ç´¢å¼•

```sql
CREATE TABLE categories (
  category_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  name TEXT NOT NULL,
  type TEXT NOT NULL,
  icon TEXT NOT NULL DEFAULT 'ğŸ“¦',
  color TEXT NOT NULL DEFAULT '#1890FF',
  parent_category_id INTEGER DEFAULT 0,
  sort_order INTEGER DEFAULT 0,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  is_deleted INTEGER DEFAULT 0,
  UNIQUE(user_id, name, type)
);

-- ç”¨æˆ·+ç±»å‹å¤åˆç´¢å¼•ï¼ˆåˆ†ç±»åˆ—è¡¨æŸ¥è¯¢ï¼‰
CREATE INDEX IF NOT EXISTS idx_categories_user_type 
ON categories (user_id, type) WHERE is_deleted = 0;

-- å±‚çº§æŸ¥è¯¢ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_categories_parent 
ON categories (user_id, parent_category_id) WHERE is_deleted = 0;

-- æ’åºç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_categories_sort 
ON categories (user_id, sort_order, category_id);

-- å”¯ä¸€çº¦æŸç´¢å¼•ï¼ˆè‡ªåŠ¨åˆ›å»ºï¼‰
-- UNIQUE(user_id, name, type)
```

#### 2.2.4 Bills è¡¨ç´¢å¼•ï¼ˆæ ¸å¿ƒè¡¨ï¼‰

```sql
CREATE TABLE bills (
  bill_id INTEGER PRIMARY KEY AUTOINCREMENT,
  account_id INTEGER NOT NULL,
  category_id INTEGER NOT NULL,
  amount REAL NOT NULL,
  type TEXT NOT NULL,
  note TEXT,
  transaction_date TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  is_deleted INTEGER DEFAULT 0,
  FOREIGN KEY (account_id) REFERENCES accounts(account_id),
  FOREIGN KEY (category_id) REFERENCES categories(category_id)
);

-- è´¦æˆ·æŸ¥è¯¢ç´¢å¼•ï¼ˆæŸ¥è¯¢æŸè´¦æˆ·çš„æ‰€æœ‰è´¦å•ï¼‰
CREATE INDEX IF NOT EXISTS idx_bills_account 
ON bills (account_id, transaction_date DESC) WHERE is_deleted = 0;

-- åˆ†ç±»æŸ¥è¯¢ç´¢å¼•ï¼ˆæŸ¥è¯¢æŸåˆ†ç±»çš„æ‰€æœ‰è´¦å•ï¼‰
CREATE INDEX IF NOT EXISTS idx_bills_category 
ON bills (category_id, transaction_date DESC) WHERE is_deleted = 0;

-- æ—¥æœŸèŒƒå›´æŸ¥è¯¢ç´¢å¼•ï¼ˆæœ€é«˜é¢‘ï¼‰
CREATE INDEX IF NOT EXISTS idx_bills_date 
ON bills (transaction_date DESC, bill_id DESC) WHERE is_deleted = 0;

-- ç±»å‹+æ—¥æœŸå¤åˆç´¢å¼•ï¼ˆæ”¶å…¥/æ”¯å‡ºç»Ÿè®¡ï¼‰
CREATE INDEX IF NOT EXISTS idx_bills_type_date 
ON bills (type, transaction_date DESC) WHERE is_deleted = 0;

-- è´¦æˆ·+æ—¥æœŸå¤åˆç´¢å¼•ï¼ˆè´¦æˆ·æµæ°´ï¼‰
CREATE INDEX IF NOT EXISTS idx_bills_account_date 
ON bills (account_id, transaction_date DESC, type) WHERE is_deleted = 0;

-- è¦†ç›–ç´¢å¼•ï¼ˆé‡‘é¢ç»Ÿè®¡æŸ¥è¯¢ï¼‰
CREATE INDEX IF NOT EXISTS idx_bills_stat 
ON bills (account_id, type, transaction_date, amount) WHERE is_deleted = 0;
```

#### 2.2.5 Budgets è¡¨ç´¢å¼•

```sql
CREATE TABLE budgets (
  budget_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  category_id INTEGER NOT NULL,
  amount REAL NOT NULL,
  period TEXT NOT NULL,
  start_date TEXT NOT NULL,
  end_date TEXT,
  is_active INTEGER DEFAULT 1,
  is_deleted INTEGER DEFAULT 0,
  created_at TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(user_id),
  FOREIGN KEY (category_id) REFERENCES categories(category_id)
);

-- ç”¨æˆ·é¢„ç®—æŸ¥è¯¢
CREATE INDEX IF NOT EXISTS idx_budgets_user 
ON budgets (user_id, is_active) WHERE is_deleted = 0;

-- åˆ†ç±»é¢„ç®—æŸ¥è¯¢
CREATE INDEX IF NOT EXISTS idx_budgets_category 
ON budgets (category_id, is_active) WHERE is_deleted = 0;

-- æ—¥æœŸèŒƒå›´æŸ¥è¯¢
CREATE INDEX IF NOT EXISTS idx_budgets_date 
ON budgets (user_id, start_date, end_date) WHERE is_deleted = 0;
```

#### 2.2.6 Tags è¡¨ç´¢å¼•

```sql
CREATE TABLE tags (
  tag_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  name TEXT NOT NULL,
  color TEXT DEFAULT '#52C41A',
  usage_count INTEGER DEFAULT 0,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  is_deleted INTEGER DEFAULT 0,
  UNIQUE (user_id, name)
);

-- ç”¨æˆ·æ ‡ç­¾æŸ¥è¯¢
CREATE INDEX IF NOT EXISTS idx_tags_user 
ON tags (user_id) WHERE is_deleted = 0;

-- çƒ­é—¨æ ‡ç­¾æŸ¥è¯¢ï¼ˆæŒ‰ä½¿ç”¨é¢‘ç‡æ’åºï¼‰
CREATE INDEX IF NOT EXISTS idx_tags_usage 
ON tags (user_id, usage_count DESC) WHERE is_deleted = 0;
```

#### 2.2.7 Bill_Tags å…³è”è¡¨ç´¢å¼•

```sql
CREATE TABLE bill_tags (
  bill_id INTEGER NOT NULL,
  tag_id INTEGER NOT NULL,
  created_at TEXT NOT NULL,
  PRIMARY KEY (bill_id, tag_id),
  FOREIGN KEY (bill_id) REFERENCES bills(bill_id) ON DELETE CASCADE,
  FOREIGN KEY (tag_id) REFERENCES tags(tag_id) ON DELETE CASCADE
);

-- è´¦å•æŸ¥æ ‡ç­¾
CREATE INDEX IF NOT EXISTS idx_bill_tags_bill 
ON bill_tags (bill_id);

-- æ ‡ç­¾æŸ¥è´¦å•
CREATE INDEX IF NOT EXISTS idx_bill_tags_tag 
ON bill_tags (tag_id);
```

### 2.3 éƒ¨åˆ†ç´¢å¼•ï¼ˆPartial Indexï¼‰

éƒ¨åˆ†ç´¢å¼•åªç´¢å¼•æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„è¡Œï¼Œå‡å°‘ç´¢å¼•å¤§å°ï¼Œæå‡æ€§èƒ½ã€‚

```sql
-- åªç´¢å¼•æœªåˆ é™¤çš„æ•°æ®
CREATE INDEX idx_bills_active 
ON bills (transaction_date DESC) 
WHERE is_deleted = 0;

-- åªç´¢å¼•æ´»è·ƒé¢„ç®—
CREATE INDEX idx_budgets_active 
ON budgets (user_id, category_id) 
WHERE is_active = 1 AND is_deleted = 0;
```

### 2.4 è¡¨è¾¾å¼ç´¢å¼•

å¯¹è®¡ç®—ç»“æœåˆ›å»ºç´¢å¼•ï¼Œé€‚ç”¨äºç»å¸¸ä½¿ç”¨å‡½æ•°æˆ–è¡¨è¾¾å¼çš„æŸ¥è¯¢ã€‚

```sql
-- æœˆä»½ç´¢å¼•ï¼ˆç”¨äºæœˆåº¦ç»Ÿè®¡ï¼‰
CREATE INDEX idx_bills_month 
ON bills (strftime('%Y-%m', transaction_date));

-- å¹´ä»½ç´¢å¼•
CREATE INDEX idx_bills_year 
ON bills (strftime('%Y', transaction_date));
```

## 3. æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–

### 3.1 æ‰¹é‡æ’å…¥

#### 3.1.1 äº‹åŠ¡æ‰¹é‡æ’å…¥

```typescript
export class BillDAO {
  /**
   * æ‰¹é‡æ’å…¥è´¦å•ï¼ˆäº‹åŠ¡ï¼‰
   * @param bills è´¦å•æ•°ç»„
   */
  static async bulkInsert(bills: Bill[]): Promise<void> {
    if (bills.length === 0) return;
    
    const store = DatabaseManager.getDatabase();
    await store.beginTransaction();
    
    try {
      const sql = `
        INSERT INTO bills 
          (account_id, category_id, amount, type, note, transaction_date, created_at, updated_at, is_deleted)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `;
      
      const now = new Date().toISOString();
      
      for (const bill of bills) {
        if (!bill.validate()) {
          throw new Error(`æ— æ•ˆè´¦å•æ•°æ®: ${JSON.stringify(bill)}`);
        }
        
        const params = [
          bill.accountId,
          bill.categoryId,
          bill.amount,
          bill.type,
          bill.note,
          bill.transactionDate,
          now,
          now,
          0
        ];
        
        await store.executeSql(sql, params);
      }
      
      await store.commit();
      console.log(`[BillDAO] æ‰¹é‡æ’å…¥æˆåŠŸ: ${bills.length} æ¡`);
    } catch (error) {
      await store.rollBack();
      console.error('[BillDAO] æ‰¹é‡æ’å…¥å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * æ‰¹é‡æ’å…¥ï¼ˆä¼˜åŒ–ç‰ˆ - ä½¿ç”¨ VALUES å¤šè¡Œæ’å…¥ï¼‰
   * æ³¨æ„ï¼šSQLite æœ‰å‚æ•°æ•°é‡é™åˆ¶ï¼ˆé€šå¸¸ 999 ä¸ªï¼‰
   */
  static async bulkInsertOptimized(bills: Bill[]): Promise<void> {
    if (bills.length === 0) return;
    
    const store = DatabaseManager.getDatabase();
    const BATCH_SIZE = 100; // æ¯æ‰¹æ¬¡æ’å…¥æ•°é‡
    
    await store.beginTransaction();
    
    try {
      for (let i = 0; i < bills.length; i += BATCH_SIZE) {
        const batch = bills.slice(i, i + BATCH_SIZE);
        
        // æ„å»ºå¤šè¡Œ VALUES è¯­å¥
        const placeholders = batch.map(() => '(?, ?, ?, ?, ?, ?, ?, ?, ?)').join(', ');
        const sql = `
          INSERT INTO bills 
            (account_id, category_id, amount, type, note, transaction_date, created_at, updated_at, is_deleted)
          VALUES ${placeholders}
        `;
        
        const now = new Date().toISOString();
        const params: any[] = [];
        
        for (const bill of batch) {
          params.push(
            bill.accountId,
            bill.categoryId,
            bill.amount,
            bill.type,
            bill.note,
            bill.transactionDate,
            now,
            now,
            0
          );
        }
        
        await store.executeSql(sql, params);
      }
      
      await store.commit();
      console.log(`[BillDAO] æ‰¹é‡æ’å…¥æˆåŠŸ: ${bills.length} æ¡`);
    } catch (error) {
      await store.rollBack();
      console.error('[BillDAO] æ‰¹é‡æ’å…¥å¤±è´¥:', error);
      throw error;
    }
  }
}
```

### 3.2 æ‰¹é‡æ›´æ–°

```typescript
/**
 * æ‰¹é‡æ›´æ–°è´¦å•
 * @param bills è´¦å•æ•°ç»„
 */
static async bulkUpdate(bills: Bill[]): Promise<void> {
  if (bills.length === 0) return;
  
  const store = DatabaseManager.getDatabase();
  await store.beginTransaction();
  
  try {
    const sql = `
      UPDATE bills 
      SET account_id = ?, category_id = ?, amount = ?, type = ?, 
          note = ?, transaction_date = ?, updated_at = ?
      WHERE bill_id = ? AND is_deleted = 0
    `;
    
    const now = new Date().toISOString();
    
    for (const bill of bills) {
      const params = [
        bill.accountId,
        bill.categoryId,
        bill.amount,
        bill.type,
        bill.note,
        bill.transactionDate,
        now,
        bill.billId
      ];
      
      await store.executeSql(sql, params);
    }
    
    await store.commit();
    console.log(`[BillDAO] æ‰¹é‡æ›´æ–°æˆåŠŸ: ${bills.length} æ¡`);
  } catch (error) {
    await store.rollBack();
    console.error('[BillDAO] æ‰¹é‡æ›´æ–°å¤±è´¥:', error);
    throw error;
  }
}
```

### 3.3 æ‰¹é‡åˆ é™¤

```typescript
/**
 * æ‰¹é‡è½¯åˆ é™¤è´¦å•
 * @param billIds è´¦å•IDæ•°ç»„
 */
static async bulkSoftDelete(billIds: number[]): Promise<void> {
  if (billIds.length === 0) return;
  
  const store = DatabaseManager.getDatabase();
  const now = new Date().toISOString();
  
  // ä½¿ç”¨ IN å­å¥æ‰¹é‡åˆ é™¤
  const placeholders = billIds.map(() => '?').join(', ');
  const sql = `
    UPDATE bills 
    SET is_deleted = 1, updated_at = ?
    WHERE bill_id IN (${placeholders}) AND is_deleted = 0
  `;
  
  try {
    await store.executeSql(sql, [now, ...billIds]);
    console.log(`[BillDAO] æ‰¹é‡åˆ é™¤æˆåŠŸ: ${billIds.length} æ¡`);
  } catch (error) {
    console.error('[BillDAO] æ‰¹é‡åˆ é™¤å¤±è´¥:', error);
    throw error;
  }
}
```

### 3.4 æ‰¹é‡æŸ¥è¯¢

#### 3.4.1 IN æŸ¥è¯¢

```typescript
/**
 * æ‰¹é‡æŸ¥è¯¢è´¦å•
 * @param billIds è´¦å•IDæ•°ç»„
 */
static async getBatch(billIds: number[]): Promise<Bill[]> {
  if (billIds.length === 0) return [];
  
  const store = DatabaseManager.getDatabase();
  const placeholders = billIds.map(() => '?').join(', ');
  const sql = `
    SELECT * FROM bills 
    WHERE bill_id IN (${placeholders}) AND is_deleted = 0
  `;
  
  let resultSet: relationalStore.ResultSet | null = null;
  try {
    resultSet = await store.querySql(sql, billIds);
    const bills: Bill[] = [];
    
    while (resultSet.goToNextRow()) {
      bills.push(this.mapRowToBill(resultSet));
    }
    
    return bills;
  } finally {
    resultSet?.close();
  }
}
```

#### 3.4.2 åˆ†é¡µæŸ¥è¯¢

```typescript
/**
 * åˆ†é¡µæŸ¥è¯¢è´¦å•
 * @param userId ç”¨æˆ·ID
 * @param page é¡µç ï¼ˆä»1å¼€å§‹ï¼‰
 * @param pageSize æ¯é¡µæ•°é‡
 */
static async getByPage(
  userId: number,
  page: number = 1,
  pageSize: number = 20
): Promise<PaginatedResult<Bill>> {
  const store = DatabaseManager.getDatabase();
  const offset = (page - 1) * pageSize;
  
  // æŸ¥è¯¢æ€»æ•°
  const countSql = `
    SELECT COUNT(*) as total 
    FROM bills b
    INNER JOIN accounts a ON b.account_id = a.account_id
    WHERE a.user_id = ? AND b.is_deleted = 0
  `;
  
  let countRs = await store.querySql(countSql, [userId]);
  countRs.goToNextRow();
  const total = countRs.getLong(countRs.getColumnIndex('total'));
  countRs.close();
  
  // æŸ¥è¯¢æ•°æ®
  const dataSql = `
    SELECT b.* 
    FROM bills b
    INNER JOIN accounts a ON b.account_id = a.account_id
    WHERE a.user_id = ? AND b.is_deleted = 0
    ORDER BY b.transaction_date DESC, b.bill_id DESC
    LIMIT ? OFFSET ?
  `;
  
  let dataRs: relationalStore.ResultSet | null = null;
  try {
    dataRs = await store.querySql(dataSql, [userId, pageSize, offset]);
    const bills: Bill[] = [];
    
    while (dataRs.goToNextRow()) {
      bills.push(this.mapRowToBill(dataRs));
    }
    
    return {
      data: bills,
      total: total,
      page: page,
      pageSize: pageSize,
      totalPages: Math.ceil(total / pageSize)
    };
  } finally {
    dataRs?.close();
  }
}
```

#### 3.4.3 æ¸¸æ ‡åˆ†é¡µï¼ˆCursor-based Paginationï¼‰

```typescript
/**
 * æ¸¸æ ‡åˆ†é¡µæŸ¥è¯¢ï¼ˆé€‚ç”¨äºå®æ—¶æ•°æ®æµï¼‰
 * @param userId ç”¨æˆ·ID
 * @param cursor æ¸¸æ ‡ï¼ˆä¸Šæ¬¡æŸ¥è¯¢çš„æœ€åä¸€æ¡è®°å½•IDï¼‰
 * @param limit æŸ¥è¯¢æ•°é‡
 */
static async getByCursor(
  userId: number,
  cursor: number | null = null,
  limit: number = 20
): Promise<CursorResult<Bill>> {
  const store = DatabaseManager.getDatabase();
  
  let sql = `
    SELECT b.* 
    FROM bills b
    INNER JOIN accounts a ON b.account_id = a.account_id
    WHERE a.user_id = ? AND b.is_deleted = 0
  `;
  
  const params: any[] = [userId];
  
  if (cursor !== null) {
    sql += ` AND b.bill_id < ?`;
    params.push(cursor);
  }
  
  sql += ` ORDER BY b.bill_id DESC LIMIT ?`;
  params.push(limit);
  
  let resultSet: relationalStore.ResultSet | null = null;
  try {
    resultSet = await store.querySql(sql, params);
    const bills: Bill[] = [];
    
    while (resultSet.goToNextRow()) {
      bills.push(this.mapRowToBill(resultSet));
    }
    
    const nextCursor = bills.length > 0 ? bills[bills.length - 1].billId : null;
    const hasMore = bills.length === limit;
    
    return {
      data: bills,
      nextCursor: nextCursor,
      hasMore: hasMore
    };
  } finally {
    resultSet?.close();
  }
}
```

### 3.5 èšåˆæŸ¥è¯¢ä¼˜åŒ–

#### 3.5.1 ä½¿ç”¨è¦†ç›–ç´¢å¼•

```typescript
/**
 * ç»Ÿè®¡ç”¨æˆ·æ€»æ”¶æ”¯ï¼ˆä½¿ç”¨è¦†ç›–ç´¢å¼•ï¼‰
 * @param userId ç”¨æˆ·ID
 * @param startDate å¼€å§‹æ—¥æœŸ
 * @param endDate ç»“æŸæ—¥æœŸ
 */
static async getTotalStats(
  userId: number,
  startDate: string,
  endDate: string
): Promise<TotalStats> {
  const store = DatabaseManager.getDatabase();
  
  // ä½¿ç”¨è¦†ç›–ç´¢å¼• idx_bills_stat (account_id, type, transaction_date, amount)
  const sql = `
    SELECT 
      SUM(CASE WHEN b.type = 'expense' THEN b.amount ELSE 0 END) as total_expense,
      SUM(CASE WHEN b.type = 'income' THEN b.amount ELSE 0 END) as total_income,
      COUNT(CASE WHEN b.type = 'expense' THEN 1 END) as expense_count,
      COUNT(CASE WHEN b.type = 'income' THEN 1 END) as income_count
    FROM bills b
    INNER JOIN accounts a ON b.account_id = a.account_id
    WHERE a.user_id = ? 
      AND b.is_deleted = 0
      AND b.transaction_date >= ?
      AND b.transaction_date <= ?
  `;
  
  let resultSet: relationalStore.ResultSet | null = null;
  try {
    resultSet = await store.querySql(sql, [userId, startDate, endDate]);
    
    if (resultSet.goToNextRow()) {
      return {
        totalExpense: resultSet.getDouble(resultSet.getColumnIndex('total_expense')),
        totalIncome: resultSet.getDouble(resultSet.getColumnIndex('total_income')),
        expenseCount: resultSet.getLong(resultSet.getColumnIndex('expense_count')),
        incomeCount: resultSet.getLong(resultSet.getColumnIndex('income_count'))
      };
    }
    
    return { totalExpense: 0, totalIncome: 0, expenseCount: 0, incomeCount: 0 };
  } finally {
    resultSet?.close();
  }
}
```

#### 3.5.2 åˆ†ç»„èšåˆ

```typescript
/**
 * æŒ‰æœˆç»Ÿè®¡æ”¶æ”¯
 * @param userId ç”¨æˆ·ID
 * @param year å¹´ä»½
 */
static async getMonthlyStats(userId: number, year: number): Promise<MonthlyStats[]> {
  const store = DatabaseManager.getDatabase();
  
  const sql = `
    SELECT 
      strftime('%Y-%m', b.transaction_date) as month,
      SUM(CASE WHEN b.type = 'expense' THEN b.amount ELSE 0 END) as expense,
      SUM(CASE WHEN b.type = 'income' THEN b.amount ELSE 0 END) as income,
      COUNT(*) as count
    FROM bills b
    INNER JOIN accounts a ON b.account_id = a.account_id
    WHERE a.user_id = ? 
      AND b.is_deleted = 0
      AND strftime('%Y', b.transaction_date) = ?
    GROUP BY month
    ORDER BY month ASC
  `;
  
  let resultSet: relationalStore.ResultSet | null = null;
  try {
    resultSet = await store.querySql(sql, [userId, year.toString()]);
    const stats: MonthlyStats[] = [];
    
    while (resultSet.goToNextRow()) {
      stats.push({
        month: resultSet.getString(resultSet.getColumnIndex('month')),
        expense: resultSet.getDouble(resultSet.getColumnIndex('expense')),
        income: resultSet.getDouble(resultSet.getColumnIndex('income')),
        count: resultSet.getLong(resultSet.getColumnIndex('count'))
      });
    }
    
    return stats;
  } finally {
    resultSet?.close();
  }
}
```

## 4. æŸ¥è¯¢æ€§èƒ½åˆ†æ

### 4.1 EXPLAIN QUERY PLAN

```typescript
/**
 * åˆ†ææŸ¥è¯¢è®¡åˆ’
 * @param sql SQL è¯­å¥
 * @param params å‚æ•°
 */
static async explainQuery(sql: string, params: any[]): Promise<void> {
  const store = DatabaseManager.getDatabase();
  const explainSql = `EXPLAIN QUERY PLAN ${sql}`;
  
  let resultSet: relationalStore.ResultSet | null = null;
  try {
    resultSet = await store.querySql(explainSql, params);
    
    console.log('=== Query Plan ===');
    while (resultSet.goToNextRow()) {
      const detail = resultSet.getString(resultSet.getColumnIndex('detail'));
      console.log(detail);
    }
    console.log('==================');
  } finally {
    resultSet?.close();
  }
}
```

### 4.2 æŸ¥è¯¢æ€§èƒ½ç›‘æ§

```typescript
/**
 * æŸ¥è¯¢æ€§èƒ½ç›‘æ§è£…é¥°å™¨
 */
function measureQueryTime(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = async function (...args: any[]) {
    const startTime = Date.now();
    try {
      const result = await originalMethod.apply(this, args);
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      if (duration > 100) { // è¶…è¿‡ 100ms è®°å½•è­¦å‘Š
        console.warn(`[Performance] ${propertyKey} took ${duration}ms`);
      } else {
        console.log(`[Performance] ${propertyKey} took ${duration}ms`);
      }
      
      return result;
    } catch (error) {
      const endTime = Date.now();
      console.error(`[Performance] ${propertyKey} failed after ${endTime - startTime}ms`);
      throw error;
    }
  };
  
  return descriptor;
}

// ä½¿ç”¨ç¤ºä¾‹
export class BillDAO {
  @measureQueryTime
  static async getByDateRange(userId: number, startDate: string, endDate: string): Promise<Bill[]> {
    // æŸ¥è¯¢å®ç°...
  }
}
```

## 5. ç¼“å­˜ç­–ç•¥

### 5.1 å†…å­˜ç¼“å­˜

```typescript
export class CacheManager {
  private static cache: Map<string, CacheEntry> = new Map();
  private static readonly DEFAULT_TTL = 5 * 60 * 1000; // 5åˆ†é’Ÿ
  
  /**
   * è·å–ç¼“å­˜
   */
  static get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    
    if (!entry) return null;
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() > entry.expireAt) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.value as T;
  }
  
  /**
   * è®¾ç½®ç¼“å­˜
   */
  static set<T>(key: string, value: T, ttl: number = this.DEFAULT_TTL): void {
    this.cache.set(key, {
      value: value,
      expireAt: Date.now() + ttl
    });
  }
  
  /**
   * æ¸…é™¤ç¼“å­˜
   */
  static clear(pattern?: string): void {
    if (!pattern) {
      this.cache.clear();
      return;
    }
    
    const regex = new RegExp(pattern);
    for (const key of this.cache.keys()) {
      if (regex.test(key)) {
        this.cache.delete(key);
      }
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
export class CategoryDAO {
  static async getAll(userId: number): Promise<Category[]> {
    const cacheKey = `categories:${userId}`;
    
    // å°è¯•ä»ç¼“å­˜è·å–
    let categories = CacheManager.get<Category[]>(cacheKey);
    if (categories) {
      console.log('[CategoryDAO] ä»ç¼“å­˜è·å–');
      return categories;
    }
    
    // ä»æ•°æ®åº“æŸ¥è¯¢
    categories = await this.queryFromDatabase(userId);
    
    // å†™å…¥ç¼“å­˜
    CacheManager.set(cacheKey, categories);
    
    return categories;
  }
  
  static async insert(category: Category): Promise<void> {
    await this.insertToDatabase(category);
    
    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    CacheManager.clear(`categories:${category.userId}`);
  }
}
```

## 6. æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 6.1 æ•°æ®åº“é…ç½®ä¼˜åŒ–

```typescript
export class DatabaseManager {
  static async optimizeDatabase(): Promise<void> {
    const store = this.getDatabase();
    
    try {
      // è®¾ç½® WAL æ¨¡å¼ï¼ˆWrite-Ahead Loggingï¼‰
      await store.executeSql('PRAGMA journal_mode=WAL');
      
      // è®¾ç½®åŒæ­¥æ¨¡å¼
      await store.executeSql('PRAGMA synchronous=NORMAL');
      
      // è®¾ç½®ç¼“å­˜å¤§å°ï¼ˆå•ä½ï¼šé¡µï¼Œé»˜è®¤é¡µå¤§å° 4KBï¼‰
      await store.executeSql('PRAGMA cache_size=10000'); // çº¦ 40MB
      
      // è®¾ç½®ä¸´æ—¶å­˜å‚¨ä½ç½®
      await store.executeSql('PRAGMA temp_store=MEMORY');
      
      // å¯ç”¨å¤–é”®çº¦æŸ
      await store.executeSql('PRAGMA foreign_keys=ON');
      
      console.log('[DatabaseManager] æ•°æ®åº“ä¼˜åŒ–å®Œæˆ');
    } catch (error) {
      console.error('[DatabaseManager] æ•°æ®åº“ä¼˜åŒ–å¤±è´¥:', error);
    }
  }
}
```

### 6.2 å®šæœŸç»´æŠ¤

```typescript
/**
 * æ•°æ®åº“ç»´æŠ¤ä»»åŠ¡
 */
export class DatabaseMaintenance {
  /**
   * åˆ†æè¡¨ç»Ÿè®¡ä¿¡æ¯
   */
  static async analyze(): Promise<void> {
    const store = DatabaseManager.getDatabase();
    
    try {
      await store.executeSql('ANALYZE');
      console.log('[Maintenance] ç»Ÿè®¡ä¿¡æ¯åˆ†æå®Œæˆ');
    } catch (error) {
      console.error('[Maintenance] åˆ†æå¤±è´¥:', error);
    }
  }
  
  /**
   * æ¸…ç†ç¢ç‰‡
   */
  static async vacuum(): Promise<void> {
    const store = DatabaseManager.getDatabase();
    
    try {
      await store.executeSql('VACUUM');
      console.log('[Maintenance] æ•°æ®åº“æ¸…ç†å®Œæˆ');
    } catch (error) {
      console.error('[Maintenance] æ¸…ç†å¤±è´¥:', error);
    }
  }
  
  /**
   * é‡å»ºç´¢å¼•
   */
  static async reindex(): Promise<void> {
    const store = DatabaseManager.getDatabase();
    
    try {
      await store.executeSql('REINDEX');
      console.log('[Maintenance] ç´¢å¼•é‡å»ºå®Œæˆ');
    } catch (error) {
      console.error('[Maintenance] é‡å»ºå¤±è´¥:', error);
    }
  }
}
```

## 7. æœ€ä½³å®è·µæ€»ç»“

### 7.1 ç´¢å¼•è®¾è®¡
- ä¸ºé«˜é¢‘æŸ¥è¯¢å­—æ®µåˆ›å»ºç´¢å¼•
- ä½¿ç”¨å¤åˆç´¢å¼•ä¼˜åŒ–å¤šæ¡ä»¶æŸ¥è¯¢
- ä½¿ç”¨éƒ¨åˆ†ç´¢å¼•å‡å°‘ç´¢å¼•å¤§å°
- é¿å…è¿‡åº¦ç´¢å¼•

### 7.2 æŸ¥è¯¢ä¼˜åŒ–
- åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µï¼Œé¿å… SELECT *
- ä½¿ç”¨ LIMIT é™åˆ¶ç»“æœé›†
- åˆç†ä½¿ç”¨ JOINï¼Œé¿å…ç¬›å¡å°”ç§¯
- ä½¿ç”¨è¦†ç›–ç´¢å¼•å‡å°‘å›è¡¨

### 7.3 æ‰¹é‡æ“ä½œ
- ä½¿ç”¨äº‹åŠ¡æ‰¹é‡æ“ä½œ
- åˆå¹¶å¤šä¸ªå°æŸ¥è¯¢
- ä½¿ç”¨ IN å­å¥æ‰¹é‡æŸ¥è¯¢
- æ³¨æ„å‚æ•°æ•°é‡é™åˆ¶

### 7.4 æ€§èƒ½ç›‘æ§
- å®šæœŸåˆ†ææ…¢æŸ¥è¯¢
- ä½¿ç”¨ EXPLAIN åˆ†ææŸ¥è¯¢è®¡åˆ’
- ç›‘æ§æ•°æ®åº“å¤§å°å’Œæ€§èƒ½æŒ‡æ ‡
- å®šæœŸç»´æŠ¤æ•°æ®åº“

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-11-10  
**é€‚ç”¨å¹³å°**: HarmonyOS (ArkTS)
